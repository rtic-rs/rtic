<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="USB FS/LS controller device registers"><title>rp2040_pac::usbctrl_regs - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="rp2040_pac" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../rp2040_pac/index.html">rp2040_<wbr>pac</a><span class="version">0.6.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module usbctrl_<wbr>regs</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate rp2040_<wbr>pac</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">rp2040_pac</a></div><h1>Module <span>usbctrl_regs</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/rp2040_pac/usbctrl_regs.rs.html#1-448">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>USB FS/LS controller device registers</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="mod" href="addr_endp/index.html" title="mod rp2040_pac::usbctrl_regs::addr_endp">addr_<wbr>endp</a></dt><dd>Device address and endpoint control</dd><dt><a class="mod" href="buff_cpu_should_handle/index.html" title="mod rp2040_pac::usbctrl_regs::buff_cpu_should_handle">buff_<wbr>cpu_<wbr>should_<wbr>handle</a></dt><dd>Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered.</dd><dt><a class="mod" href="buff_status/index.html" title="mod rp2040_pac::usbctrl_regs::buff_status">buff_<wbr>status</a></dt><dd>Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle.</dd><dt><a class="mod" href="ep_abort/index.html" title="mod rp2040_pac::usbctrl_regs::ep_abort">ep_<wbr>abort</a></dt><dd>Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in <code>EP_ABORT_DONE</code> is set when it is safe to modify the buffer control register.</dd><dt><a class="mod" href="ep_abort_done/index.html" title="mod rp2040_pac::usbctrl_regs::ep_abort_done">ep_<wbr>abort_<wbr>done</a></dt><dd>Device only: Used in conjunction with <code>EP_ABORT</code>. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register.</dd><dt><a class="mod" href="ep_stall_arm/index.html" title="mod rp2040_pac::usbctrl_regs::ep_stall_arm">ep_<wbr>stall_<wbr>arm</a></dt><dd>Device: this bit must be set in conjunction with the <code>STALL</code> bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received.</dd><dt><a class="mod" href="ep_status_stall_nak/index.html" title="mod rp2040_pac::usbctrl_regs::ep_status_stall_nak">ep_<wbr>status_<wbr>stall_<wbr>nak</a></dt><dd>Device: bits are set when the <code>IRQ_ON_NAK</code> or <code>IRQ_ON_STALL</code> bits are set. For EP0 this comes from <code>SIE_CTRL</code>. For all other endpoints it comes from the endpoint control register.</dd><dt><a class="mod" href="host_addr_endp/index.html" title="mod rp2040_pac::usbctrl_regs::host_addr_endp">host_<wbr>addr_<wbr>endp</a></dt><dd>Interrupt endpoints. Only valid in HOST mode.</dd><dt><a class="mod" href="int_ep_ctrl/index.html" title="mod rp2040_pac::usbctrl_regs::int_ep_ctrl">int_<wbr>ep_<wbr>ctrl</a></dt><dd>interrupt endpoint control register</dd><dt><a class="mod" href="inte/index.html" title="mod rp2040_pac::usbctrl_regs::inte">inte</a></dt><dd>Interrupt Enable</dd><dt><a class="mod" href="intf/index.html" title="mod rp2040_pac::usbctrl_regs::intf">intf</a></dt><dd>Interrupt Force</dd><dt><a class="mod" href="intr/index.html" title="mod rp2040_pac::usbctrl_regs::intr">intr</a></dt><dd>Raw Interrupts</dd><dt><a class="mod" href="ints/index.html" title="mod rp2040_pac::usbctrl_regs::ints">ints</a></dt><dd>Interrupt status after masking &amp; forcing</dd><dt><a class="mod" href="main_ctrl/index.html" title="mod rp2040_pac::usbctrl_regs::main_ctrl">main_<wbr>ctrl</a></dt><dd>Main control register</dd><dt><a class="mod" href="nak_poll/index.html" title="mod rp2040_pac::usbctrl_regs::nak_poll">nak_<wbr>poll</a></dt><dd>Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK.</dd><dt><a class="mod" href="sie_ctrl/index.html" title="mod rp2040_pac::usbctrl_regs::sie_ctrl">sie_<wbr>ctrl</a></dt><dd>SIE control register</dd><dt><a class="mod" href="sie_status/index.html" title="mod rp2040_pac::usbctrl_regs::sie_status">sie_<wbr>status</a></dt><dd>SIE status register</dd><dt><a class="mod" href="sof_rd/index.html" title="mod rp2040_pac::usbctrl_regs::sof_rd">sof_rd</a></dt><dd>Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host.</dd><dt><a class="mod" href="sof_wr/index.html" title="mod rp2040_pac::usbctrl_regs::sof_wr">sof_wr</a></dt><dd>Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time.</dd><dt><a class="mod" href="usb_muxing/index.html" title="mod rp2040_pac::usbctrl_regs::usb_muxing">usb_<wbr>muxing</a></dt><dd>Where to connect the USB controller. Should be to_phy by default.</dd><dt><a class="mod" href="usb_pwr/index.html" title="mod rp2040_pac::usbctrl_regs::usb_pwr">usb_pwr</a></dt><dd>Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable to switch over to the override value.</dd><dt><a class="mod" href="usbphy_direct/index.html" title="mod rp2040_pac::usbctrl_regs::usbphy_direct">usbphy_<wbr>direct</a></dt><dd>This register allows for direct control of the USB phy. Use in conjunction with usbphy_direct_override register to enable each override bit.</dd><dt><a class="mod" href="usbphy_direct_override/index.html" title="mod rp2040_pac::usbctrl_regs::usbphy_direct_override">usbphy_<wbr>direct_<wbr>override</a></dt><dd>Override enable for each control in usbphy_direct</dd><dt><a class="mod" href="usbphy_trim/index.html" title="mod rp2040_pac::usbctrl_regs::usbphy_trim">usbphy_<wbr>trim</a></dt><dd>Used to adjust trim values of USB phy pull down resistors.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.RegisterBlock.html" title="struct rp2040_pac::usbctrl_regs::RegisterBlock">Register<wbr>Block</a></dt><dd>Register block</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="type" href="type.ADDR_ENDP.html" title="type rp2040_pac::usbctrl_regs::ADDR_ENDP">ADDR_<wbr>ENDP</a></dt><dd>ADDR_ENDP (rw) register accessor: Device address and endpoint control</dd><dt><a class="type" href="type.BUFF_CPU_SHOULD_HANDLE.html" title="type rp2040_pac::usbctrl_regs::BUFF_CPU_SHOULD_HANDLE">BUFF_<wbr>CPU_<wbr>SHOULD_<wbr>HANDLE</a></dt><dd>BUFF_CPU_SHOULD_HANDLE (r) register accessor: Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered.</dd><dt><a class="type" href="type.BUFF_STATUS.html" title="type rp2040_pac::usbctrl_regs::BUFF_STATUS">BUFF_<wbr>STATUS</a></dt><dd>BUFF_STATUS (rw) register accessor: Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle.</dd><dt><a class="type" href="type.EP_ABORT.html" title="type rp2040_pac::usbctrl_regs::EP_ABORT">EP_<wbr>ABORT</a></dt><dd>EP_ABORT (rw) register accessor: Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in <code>EP_ABORT_DONE</code> is set when it is safe to modify the buffer control register.</dd><dt><a class="type" href="type.EP_ABORT_DONE.html" title="type rp2040_pac::usbctrl_regs::EP_ABORT_DONE">EP_<wbr>ABORT_<wbr>DONE</a></dt><dd>EP_ABORT_DONE (rw) register accessor: Device only: Used in conjunction with <code>EP_ABORT</code>. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register.</dd><dt><a class="type" href="type.EP_STALL_ARM.html" title="type rp2040_pac::usbctrl_regs::EP_STALL_ARM">EP_<wbr>STALL_<wbr>ARM</a></dt><dd>EP_STALL_ARM (rw) register accessor: Device: this bit must be set in conjunction with the <code>STALL</code> bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received.</dd><dt><a class="type" href="type.EP_STATUS_STALL_NAK.html" title="type rp2040_pac::usbctrl_regs::EP_STATUS_STALL_NAK">EP_<wbr>STATUS_<wbr>STALL_<wbr>NAK</a></dt><dd>EP_STATUS_STALL_NAK (rw) register accessor: Device: bits are set when the <code>IRQ_ON_NAK</code> or <code>IRQ_ON_STALL</code> bits are set. For EP0 this comes from <code>SIE_CTRL</code>. For all other endpoints it comes from the endpoint control register.</dd><dt><a class="type" href="type.HOST_ADDR_ENDP.html" title="type rp2040_pac::usbctrl_regs::HOST_ADDR_ENDP">HOST_<wbr>ADDR_<wbr>ENDP</a></dt><dd>HOST_ADDR_ENDP (rw) register accessor: Interrupt endpoints. Only valid in HOST mode.</dd><dt><a class="type" href="type.INTE.html" title="type rp2040_pac::usbctrl_regs::INTE">INTE</a></dt><dd>INTE (rw) register accessor: Interrupt Enable</dd><dt><a class="type" href="type.INTF.html" title="type rp2040_pac::usbctrl_regs::INTF">INTF</a></dt><dd>INTF (rw) register accessor: Interrupt Force</dd><dt><a class="type" href="type.INTR.html" title="type rp2040_pac::usbctrl_regs::INTR">INTR</a></dt><dd>INTR (r) register accessor: Raw Interrupts</dd><dt><a class="type" href="type.INTS.html" title="type rp2040_pac::usbctrl_regs::INTS">INTS</a></dt><dd>INTS (r) register accessor: Interrupt status after masking &amp; forcing</dd><dt><a class="type" href="type.INT_EP_CTRL.html" title="type rp2040_pac::usbctrl_regs::INT_EP_CTRL">INT_<wbr>EP_<wbr>CTRL</a></dt><dd>INT_EP_CTRL (rw) register accessor: interrupt endpoint control register</dd><dt><a class="type" href="type.MAIN_CTRL.html" title="type rp2040_pac::usbctrl_regs::MAIN_CTRL">MAIN_<wbr>CTRL</a></dt><dd>MAIN_CTRL (rw) register accessor: Main control register</dd><dt><a class="type" href="type.NAK_POLL.html" title="type rp2040_pac::usbctrl_regs::NAK_POLL">NAK_<wbr>POLL</a></dt><dd>NAK_POLL (rw) register accessor: Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK.</dd><dt><a class="type" href="type.SIE_CTRL.html" title="type rp2040_pac::usbctrl_regs::SIE_CTRL">SIE_<wbr>CTRL</a></dt><dd>SIE_CTRL (rw) register accessor: SIE control register</dd><dt><a class="type" href="type.SIE_STATUS.html" title="type rp2040_pac::usbctrl_regs::SIE_STATUS">SIE_<wbr>STATUS</a></dt><dd>SIE_STATUS (rw) register accessor: SIE status register</dd><dt><a class="type" href="type.SOF_RD.html" title="type rp2040_pac::usbctrl_regs::SOF_RD">SOF_RD</a></dt><dd>SOF_RD (r) register accessor: Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host.</dd><dt><a class="type" href="type.SOF_WR.html" title="type rp2040_pac::usbctrl_regs::SOF_WR">SOF_WR</a></dt><dd>SOF_WR (w) register accessor: Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time.</dd><dt><a class="type" href="type.USBPHY_DIRECT.html" title="type rp2040_pac::usbctrl_regs::USBPHY_DIRECT">USBPHY_<wbr>DIRECT</a></dt><dd>USBPHY_DIRECT (rw) register accessor: This register allows for direct control of the USB phy. Use in conjunction with usbphy_direct_override register to enable each override bit.</dd><dt><a class="type" href="type.USBPHY_DIRECT_OVERRIDE.html" title="type rp2040_pac::usbctrl_regs::USBPHY_DIRECT_OVERRIDE">USBPHY_<wbr>DIRECT_<wbr>OVERRIDE</a></dt><dd>USBPHY_DIRECT_OVERRIDE (rw) register accessor: Override enable for each control in usbphy_direct</dd><dt><a class="type" href="type.USBPHY_TRIM.html" title="type rp2040_pac::usbctrl_regs::USBPHY_TRIM">USBPHY_<wbr>TRIM</a></dt><dd>USBPHY_TRIM (rw) register accessor: Used to adjust trim values of USB phy pull down resistors.</dd><dt><a class="type" href="type.USB_MUXING.html" title="type rp2040_pac::usbctrl_regs::USB_MUXING">USB_<wbr>MUXING</a></dt><dd>USB_MUXING (rw) register accessor: Where to connect the USB controller. Should be to_phy by default.</dd><dt><a class="type" href="type.USB_PWR.html" title="type rp2040_pac::usbctrl_regs::USB_PWR">USB_PWR</a></dt><dd>USB_PWR (rw) register accessor: Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable to switch over to the override value.</dd></dl></section></div></main></body></html>