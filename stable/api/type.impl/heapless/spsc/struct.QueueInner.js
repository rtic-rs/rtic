(function() {
    var type_impls = Object.fromEntries([["heapless",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-QueueInner%3CT,+S%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#696-704\">Source</a><a href=\"#impl-Debug-for-QueueInner%3CT,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, S&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for <a class=\"struct\" href=\"heapless/spsc/struct.QueueInner.html\" title=\"struct heapless::spsc::QueueInner\">QueueInner</a>&lt;T, S&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a>,\n    S: <a class=\"trait\" href=\"heapless/storage/trait.Storage.html\" title=\"trait heapless::storage::Storage\">Storage</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#701-703\">Source</a><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.93.1/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/1.93.1/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"type\" href=\"https://doc.rust-lang.org/1.93.1/core/fmt/type.Result.html\" title=\"type core::fmt::Result\">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/1.93.1/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","heapless::spsc::Queue","heapless::spsc::QueueView"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Drop-for-QueueInner%3CT,+S%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#686-694\">Source</a><a href=\"#impl-Drop-for-QueueInner%3CT,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, S: <a class=\"trait\" href=\"heapless/storage/trait.Storage.html\" title=\"trait heapless::storage::Storage\">Storage</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/ops/drop/trait.Drop.html\" title=\"trait core::ops::drop::Drop\">Drop</a> for <a class=\"struct\" href=\"heapless/spsc/struct.QueueInner.html\" title=\"struct heapless::spsc::QueueInner\">QueueInner</a>&lt;T, S&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.drop\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#687-693\">Source</a><a href=\"#method.drop\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.93.1/core/ops/drop/trait.Drop.html#tymethod.drop\" class=\"fn\">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href=\"https://doc.rust-lang.org/1.93.1/core/ops/drop/trait.Drop.html#tymethod.drop\">Read more</a></div></details></div></details>","Drop","heapless::spsc::Queue","heapless::spsc::QueueView"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Hash-for-QueueInner%3CT,+S%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#706-717\">Source</a><a href=\"#impl-Hash-for-QueueInner%3CT,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, S&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> for <a class=\"struct\" href=\"heapless/spsc/struct.QueueInner.html\" title=\"struct heapless::spsc::QueueInner\">QueueInner</a>&lt;T, S&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a>,\n    S: <a class=\"trait\" href=\"heapless/storage/trait.Storage.html\" title=\"trait heapless::storage::Storage\">Storage</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.hash\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#711-716\">Source</a><a href=\"#method.hash\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.93.1/core/hash/trait.Hash.html#tymethod.hash\" class=\"fn\">hash</a>&lt;H: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/hash/trait.Hasher.html\" title=\"trait core::hash::Hasher\">Hasher</a>&gt;(&amp;self, state: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/core/primitive.reference.html\">&amp;mut H</a>)</h4></section></summary><div class='docblock'>Feeds this value into the given <a href=\"https://doc.rust-lang.org/1.93.1/core/hash/trait.Hasher.html\" title=\"trait core::hash::Hasher\"><code>Hasher</code></a>. <a href=\"https://doc.rust-lang.org/1.93.1/core/hash/trait.Hash.html#tymethod.hash\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.hash_slice\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.3.0\">1.3.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.93.1/src/core/hash/mod.rs.html#235-237\">Source</a></span><a href=\"#method.hash_slice\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.93.1/core/hash/trait.Hash.html#method.hash_slice\" class=\"fn\">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/core/primitive.reference.html\">&amp;mut H</a>)<div class=\"where\">where\n    H: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/hash/trait.Hasher.html\" title=\"trait core::hash::Hasher\">Hasher</a>,\n    Self: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href=\"https://doc.rust-lang.org/1.93.1/core/hash/trait.Hasher.html\" title=\"trait core::hash::Hasher\"><code>Hasher</code></a>. <a href=\"https://doc.rust-lang.org/1.93.1/core/hash/trait.Hash.html#method.hash_slice\">Read more</a></div></details></div></details>","Hash","heapless::spsc::Queue","heapless::spsc::QueueView"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq%3CQueueInner%3CT,+S2%3E%3E-for-QueueInner%3CT,+S%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#586-595\">Source</a><a href=\"#impl-PartialEq%3CQueueInner%3CT,+S2%3E%3E-for-QueueInner%3CT,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, S, S2&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>&lt;<a class=\"struct\" href=\"heapless/spsc/struct.QueueInner.html\" title=\"struct heapless::spsc::QueueInner\">QueueInner</a>&lt;T, S2&gt;&gt; for <a class=\"struct\" href=\"heapless/spsc/struct.QueueInner.html\" title=\"struct heapless::spsc::QueueInner\">QueueInner</a>&lt;T, S&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>,\n    S: <a class=\"trait\" href=\"heapless/storage/trait.Storage.html\" title=\"trait heapless::storage::Storage\">Storage</a>,\n    S2: <a class=\"trait\" href=\"heapless/storage/trait.Storage.html\" title=\"trait heapless::storage::Storage\">Storage</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#592-594\">Source</a><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.93.1/core/cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"heapless/spsc/struct.QueueInner.html\" title=\"struct heapless::spsc::QueueInner\">QueueInner</a>&lt;T, S2&gt;) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/core/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.93.1/src/core/cmp.rs.html#264\">Source</a></span><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.93.1/core/cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/core/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/core/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,\nand should not be overridden without very good reason.</div></details></div></details>","PartialEq<QueueInner<T, S2>>","heapless::spsc::Queue","heapless::spsc::QueueView"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-QueueInner%3CT,+S%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#172-441\">Source</a><a href=\"#impl-QueueInner%3CT,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, S: <a class=\"trait\" href=\"heapless/storage/trait.Storage.html\" title=\"trait heapless::storage::Storage\">Storage</a>&gt; <a class=\"struct\" href=\"heapless/spsc/struct.QueueInner.html\" title=\"struct heapless::spsc::QueueInner\">QueueInner</a>&lt;T, S&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_view\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#174-176\">Source</a><h4 class=\"code-header\">pub fn <a href=\"#method.as_view\" class=\"fn\">as_view</a>(&amp;self) -&gt; &amp;<a class=\"type\" href=\"heapless/spsc/type.QueueView.html\" title=\"type heapless::spsc::QueueView\">QueueView</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Get a reference to the <code>Queue</code>, erasing the <code>N</code> const-generic.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_mut_view\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#179-181\">Source</a><h4 class=\"code-header\">pub fn <a href=\"#method.as_mut_view\" class=\"fn\">as_mut_view</a>(&amp;mut self) -&gt; &amp;mut <a class=\"type\" href=\"heapless/spsc/type.QueueView.html\" title=\"type heapless::spsc::QueueView\">QueueView</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Get a mutable reference to the <code>Queue</code>, erasing the <code>N</code> const-generic.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.capacity\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#195-197\">Source</a><h4 class=\"code-header\">pub fn <a href=\"#method.capacity\" class=\"fn\">capacity</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/core/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the maximum number of elements the queue can hold.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.len\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#201-209\">Source</a><h4 class=\"code-header\">pub fn <a href=\"#method.len\" class=\"fn\">len</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/core/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the number of elements in the queue.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_empty\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#213-215\">Source</a><h4 class=\"code-header\">pub fn <a href=\"#method.is_empty\" class=\"fn\">is_empty</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/core/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns whether the queue is empty.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_full\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#219-221\">Source</a><h4 class=\"code-header\">pub fn <a href=\"#method.is_full\" class=\"fn\">is_full</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/core/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns whether the queue is full.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.iter\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#224-230\">Source</a><h4 class=\"code-header\">pub fn <a href=\"#method.iter\" class=\"fn\">iter</a>(&amp;self) -&gt; <a class=\"struct\" href=\"heapless/spsc/struct.Iter.html\" title=\"struct heapless::spsc::Iter\">Iter</a>&lt;'_, T&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Iter&lt;&#39;_, T&gt;\">ⓘ</a></h4></section></summary><div class=\"docblock\"><p>Iterates from the front of the queue to the back.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.iter_mut\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#233-240\">Source</a><h4 class=\"code-header\">pub fn <a href=\"#method.iter_mut\" class=\"fn\">iter_mut</a>(&amp;mut self) -&gt; <a class=\"struct\" href=\"heapless/spsc/struct.IterMut.html\" title=\"struct heapless::spsc::IterMut\">IterMut</a>&lt;'_, T&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"IterMut&lt;&#39;_, T&gt;\">ⓘ</a></h4></section></summary><div class=\"docblock\"><p>Returns an iterator that allows modifying each value.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.enqueue\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#246-248\">Source</a><h4 class=\"code-header\">pub fn <a href=\"#method.enqueue\" class=\"fn\">enqueue</a>(&amp;mut self, item: T) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.93.1/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/core/primitive.unit.html\">()</a>, T&gt;</h4></section></summary><div class=\"docblock\"><p>Adds an <code>item</code> to the end of the queue.</p>\n<p>Returns back the <code>item</code> if the queue is full.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.dequeue\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#252-254\">Source</a><h4 class=\"code-header\">pub fn <a href=\"#method.dequeue\" class=\"fn\">dequeue</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.93.1/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the item in the front of the queue, or <code>None</code> if the queue is empty.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.peek\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#271-278\">Source</a><h4 class=\"code-header\">pub fn <a href=\"#method.peek\" class=\"fn\">peek</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.93.1/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/core/primitive.reference.html\">&amp;T</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a reference to the item in the front of the queue without dequeuing it, or\n<code>None</code> if the queue is empty.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>heapless::spsc::Queue;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>queue: Queue&lt;u8, <span class=\"number\">235</span>&gt; = Queue::new();\n<span class=\"kw\">let </span>(<span class=\"kw-2\">mut </span>producer, <span class=\"kw-2\">mut </span>consumer) = queue.split();\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, consumer.peek());\nproducer.enqueue(<span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>), consumer.peek());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>), consumer.dequeue());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, consumer.peek());</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.enqueue_unchecked\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#318-320\">Source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.enqueue_unchecked\" class=\"fn\">enqueue_unchecked</a>(&amp;mut self, item: T)</h4></section></summary><div class=\"docblock\"><p>Adds an <code>item</code> to the end of the queue, without checking if it’s full.</p>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">§</a>Safety</h5>\n<p>If the queue is full, this operation will leak a value (<code>T</code>’s destructor won’t run on\nthe value that got overwritten by <code>item</code>), <em>and</em> will allow the <code>dequeue</code> operation\nto create a copy of <code>item</code>, which could result in <code>T</code>’s destructor running on <code>item</code>\ntwice.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.dequeue_unchecked\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#363-365\">Source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.dequeue_unchecked\" class=\"fn\">dequeue_unchecked</a>(&amp;mut self) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Returns the item in the front of the queue, without checking if there is something in the\nqueue.</p>\n<h5 id=\"safety-1\"><a class=\"doc-anchor\" href=\"#safety-1\">§</a>Safety</h5>\n<p>The queue must not be empty. Calling this on an empty queue causes <a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">undefined behavior</a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split\" class=\"method\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#435-440\">Source</a><h4 class=\"code-header\">pub fn <a href=\"#method.split\" class=\"fn\">split</a>(&amp;mut self) -&gt; (<a class=\"struct\" href=\"heapless/spsc/struct.Producer.html\" title=\"struct heapless::spsc::Producer\">Producer</a>&lt;'_, T&gt;, <a class=\"struct\" href=\"heapless/spsc/struct.Consumer.html\" title=\"struct heapless::spsc::Consumer\">Consumer</a>&lt;'_, T&gt;)</h4></section></summary><div class=\"docblock\"><p>Splits a queue into producer and consumer endpoints.</p>\n<p>If you need this function in a <code>const</code> context,\ncheck out <a href=\"heapless/spsc/struct.QueueInner.html#method.split_const\" title=\"method heapless::spsc::QueueInner::split_const\"><code>Queue::split_const</code></a> and <a href=\"heapless/spsc/struct.QueueInner.html#method.split_const\" title=\"method heapless::spsc::QueueInner::split_const\"><code>QueueView::split_const</code></a>.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<p>Create a queue and split it at runtime</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>queue: Queue&lt;(), <span class=\"number\">4</span>&gt; = Queue::new();\n<span class=\"kw\">let </span>(<span class=\"kw-2\">mut </span>producer, <span class=\"kw-2\">mut </span>consumer) = queue.split();\nproducer.enqueue(()).unwrap();\n<span class=\"macro\">assert_eq!</span>(consumer.dequeue(), <span class=\"prelude-val\">Some</span>(()));</code></pre></div>\n<p>Create a queue at compile time, split it at runtime,\nand pass it to an interrupt handler via a mutex.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>core::cell::RefCell;\n<span class=\"kw\">use </span>critical_section::Mutex;\n<span class=\"kw\">use </span>heapless::spsc::{Producer, Queue};\n\n<span class=\"kw\">static </span>PRODUCER: Mutex&lt;RefCell&lt;<span class=\"prelude-ty\">Option</span>&lt;Producer&lt;<span class=\"lifetime\">'static</span>, ()&gt;&gt;&gt;&gt; =\n    { Mutex::new(RefCell::new(<span class=\"prelude-val\">None</span>)) };\n\n<span class=\"kw\">fn </span>interrupt() {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>producer = {\n        <span class=\"kw\">static </span><span class=\"kw-2\">mut </span>P: <span class=\"prelude-ty\">Option</span>&lt;Producer&lt;<span class=\"lifetime\">'static</span>, ()&gt;&gt; = <span class=\"prelude-val\">None</span>;\n        <span class=\"comment\">// SAFETY: Mutable access to `P` is allowed exclusively in this scope\n        // and `interrupt` cannot be called directly or preempt itself.\n        </span><span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;mut </span>P }\n    }\n    .get_or_insert_with(|| {\n        critical_section::with(|cs| PRODUCER.borrow_ref_mut(cs).take().unwrap())\n    });\n\n    producer.enqueue(()).unwrap();\n}\n\n<span class=\"kw\">fn </span>main() {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>consumer = {\n        <span class=\"kw\">let </span>(p, c) = {\n            <span class=\"kw\">static </span><span class=\"kw-2\">mut </span>Q: Queue&lt;(), <span class=\"number\">4</span>&gt; = Queue::new();\n            <span class=\"comment\">// SAFETY: `Q` is only accessible in this scope\n            // and `main` is only called once.\n            </span><span class=\"attr\">#[allow(static_mut_refs)]\n            </span><span class=\"kw\">unsafe </span>{\n                Q.split()\n            }\n        };\n\n        critical_section::with(<span class=\"kw\">move </span>|cs| {\n            <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>producer = PRODUCER.borrow_ref_mut(cs);\n            <span class=\"kw-2\">*</span>producer = <span class=\"prelude-val\">Some</span>(p);\n        });\n\n        c\n    };\n\n    <span class=\"comment\">// Interrupt occurs.\n\n    </span>consumer.dequeue().unwrap();\n}</code></pre></div></div></details></div></details>",0,"heapless::spsc::Queue","heapless::spsc::QueueView"],["<section id=\"impl-Eq-for-QueueInner%3CT,+S%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/heapless/spsc.rs.html#597\">Source</a><a href=\"#impl-Eq-for-QueueInner%3CT,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, S: <a class=\"trait\" href=\"heapless/storage/trait.Storage.html\" title=\"trait heapless::storage::Storage\">Storage</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> for <a class=\"struct\" href=\"heapless/spsc/struct.QueueInner.html\" title=\"struct heapless::spsc::QueueInner\">QueueInner</a>&lt;T, S&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a>,</div></h3></section>","Eq","heapless::spsc::Queue","heapless::spsc::QueueView"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[24773]}