searchState.loadedDescShard("rp2040_pac", 0, "Peripheral access API for RP2040 microcontrollers …\nControl and data interface to SAR ADC\nADC\n22 - ADC_IRQ_FIFO\nRegister block for busfabric control signals and …\nBUSCTRL\nCache and branch predictor maintenance operations\nCache and branch predictor maintenance operations. Not …\nCLOCKS\nCLOCKS\n17 - CLOCKS_IRQ\nCPUID\nCPUID\nCore peripherals\nDebug Control Block\nDebug Control Block\nDMA with separate read and write masters\nDMA\n11 - DMA_IRQ_0\n12 - DMA_IRQ_1\nData Watchpoint and Trace unit\nData Watchpoint and Trace unit\nFlash Patch and Breakpoint unit\nFlash Patch and Breakpoint unit. Not available on Armv6-M.\nFloating Point Unit.\nDW_apb_i2c address block\nI2C0\n23 - I2C0_IRQ\nDW_apb_i2c address block\nI2C1\n24 - I2C1_IRQ\nImplementation Control Block.\nIO_BANK0\nIO_BANK0\n13 - IO_IRQ_BANK0\n14 - IO_IRQ_QSPI\nIO_QSPI\nIO_QSPI\nInstrumentation Trace Macrocell\nInstrumentation Trace Macrocell. Not available on Armv6-M …\nEnumeration of all the interrupts.\nMemory Protection Unit\nMemory Protection Unit\nNested Vector Interrupt Controller\nNested Vector Interrupt Controller\nNumber available in the NVIC for configuring priority\nPADS_BANK0\nPADS_BANK0\nPADS_QSPI\nPADS_QSPI\nProgrammable IO block\nPIO0\n7 - PIO0_IRQ_0\n8 - PIO0_IRQ_1\nProgrammable IO block\nPIO1\n9 - PIO1_IRQ_0\n10 - PIO1_IRQ_1\nPLL_SYS\nPLL_SYS\nPLL_USB\nPLL_USB\nPPB\nPPB\nPSM\nPSM\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nPointer to the register block\nSimple PWM\nPWM\n4 - PWM_IRQ_WRAP\nAll the peripherals.\nRESETS\nRESETS\nROSC\nROSC\nRegister block to control RTC\nRTC\n25 - RTC_IRQ\nSecurity Attribution Unit\nSystem Control Block\nSystem Control Block\nSingle-cycle IO block Provides core-local and inter-core …\nSIO\n15 - SIO_IRQ_PROC0\n16 - SIO_IRQ_PROC1\nSPI0\nSPI0\n18 - SPI0_IRQ\nSPI1\nSPI1\n19 - SPI1_IRQ\n26 - Software IRQ 0\n27 - Software IRQ 1\n28 - Software IRQ 2\n29 - Software IRQ 3\n30 - Software IRQ 4\n31 - Software IRQ 5\nRegister block for various chip control signals\nSYSCFG\nSYSINFO\nSYSINFO\nSysTick: System Timer\nSysTick: System Timer\nTestbench manager. Allows the programmer to know what …\nTBMAN\nControls time and alarms time is a 64 bit value indicating …\nTIMER\n0 - TIMER_IRQ_0\n1 - TIMER_IRQ_1\n2 - TIMER_IRQ_2\n3 - TIMER_IRQ_3\nTrace Port Interface Unit\nTrace Port Interface Unit. Not available on Armv6-M.\nUART0\nUART0\n20 - UART0_IRQ\nUART1\nUART1\n21 - UART1_IRQ\nDPRAM layout for USB device.\nUSBCTRL_DPRAM\n5 - USBCTRL_IRQ\nUSB FS/LS controller device registers\nUSBCTRL_REGS\ncontrol and status for on-chip voltage regulator and chip …\nVREG_AND_CHIP_RESET\nWATCHDOG\nWATCHDOG\nQSPI flash execute-in-place block\nXIP_CTRL\n6 - XIP_IRQ\nDW_apb_ssi has the following features:\nXIP_SSI\nControls the crystal oscillator\nXOSC\nControl and data interface to SAR ADC\nBranch predictor invalidate all\nRegister block for busfabric control signals and …\nReturns log2 of the number of words in the smallest cache …\nReturns log2 of the number of words in the smallest cache …\nReturns the number of sets and ways in the selected cache\nCleans the entire D-cache.\nCleans D-cache by address.\nCleans an object from the D-cache.\nCleans a slice from D-cache.\nCleans and invalidates the entire D-cache.\nCleans and invalidates D-cache by address.\nClears current value to 0\nSet the PENDSTCLR bit in the ICSR register which will …\nSet the PENDSVCLR bit in the ICSR register which will …\nClear the SLEEPDEEP bit in the SCR register\nClear the SLEEPONEXIT bit in the SCR register\nCLOCKS\nGet the CPI count\nReturns the current clock cycle count\nReturns <code>true</code> if the cycle counter is enabled\nReturns whether the D-cache is currently enabled.\nD-cache clean and invalidate by MVA to PoC\nD-cache clean and invalidate by set-way\nD-cache clean by MVA to PoC\nD-cache clean by MVA to PoU\nD-cache clean by set-way\nD-cache invalidate by MVA to PoC\nD-cache invalidate by set-way\nDisable the exception\nDisables counter\nDisables the cycle counter\nDisables D-cache if currently enabled.\nDisables I-cache if currently enabled.\nDisables SysTick interrupt\nDisables TRACE. See <code>DCB::enable_trace()</code> for more details\nDMA with separate read and write masters\nEnable the exception\nEnables counter\nEnables the cycle counter\nEnables D-cache if currently disabled.\nEnables I-cache if currently disabled.\nEnables SysTick interrupt\nEnables TRACE. This is for example required by the …\nGet the total cycles spent in exception processing\nGet the folded instruction count\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCommon register and bit access and modify traits\nGets clock source\nGets current value\nReturns the current clock cycle count\nReturns the NVIC priority of <code>interrupt</code>\nReturns the hardware priority of <code>system_handler</code>\nGets reload value\nReturns the reload value with which the counter would wrap …\nReturns <code>true</code> if the implementation supports a cycle counter\nReturns <code>true</code> if the the implementation supports sampling …\nReturns <code>true</code> if the implementation includes external match …\nReturns <code>true</code> if the implementation the profiling counters\nChecks if an external reference clock is available\nChecks if the counter wrapped (underflowed) since the last …\nDW_apb_i2c address block\nDW_apb_i2c address block\nReturns whether the I-cache is currently enabled.\nI-cache invalidate all to PoU\nI-cache invalidate by MVA to PoU\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInvalidates D-cache by address.\nInvalidates an object from the D-cache.\nInvalidates a slice from the D-cache.\nInvalidates the entire I-cache.\nIO_BANK0\nIO_QSPI\nIs <code>interrupt</code> active or pre-empted and stacked\nChecks if counter is enabled\nIs there a debugger attached? (see note)\nChecks if <code>interrupt</code> is enabled\nCheck if an exception is enabled\nChecks if SysTick interrupt is enabled\nChecks if <code>interrupt</code> is pending\nCheck if PENDSTSET bit in the ICSR register is set meaning …\nCheck if PENDSVSET bit in the ICSR register is set meaning …\nChecks if the calibration value is precise\nGet the additional cycles required to execute all load or …\nDisables <code>interrupt</code>\nNumber of comparators implemented\nPADS_BANK0\nPADS_QSPI\nForces <code>interrupt</code> into pending state\nProgrammable IO block\nProgrammable IO block\nPLL_SYS\nPLL_USB\nPPB\nPSM\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturns a pointer to the register block\nReturns a pointer to the register block\nReturns a pointer to the register block\nReturns a pointer to the register block\nReturns a pointer to the register block\nReturns a pointer to the register block\nReturns a pointer to the register block\nReturns a pointer to the register block\nReturns a pointer to the register block\nReturns a pointer to the register block\nReturns a pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nReturn the pointer to the register block\nSimple PWM\nRequest an IRQ in software\nRESETS\nROSC\nRegister block to control RTC\nSelects the current CCSIDR\nSets clock source\nSet the CPI count\nSet the cycle count\nSet the exception count\nSet the folded instruction count\nSet the lsu count\nSet the PENDSTSET bit in the ICSR register which will pend …\nSet the PENDSVSET bit in the ICSR register which will pend …\nSets the “priority” of <code>interrupt</code> to <code>prio</code>\nSets the hardware priority of <code>system_handler</code> to <code>prio</code>\nSets reload value\nSet the sleep count\nSet the SLEEPDEEP bit in the SCR register\nSet the SLEEPONEXIT bit in the SCR register\nSingle-cycle IO block Provides core-local and inter-core …\nGet the total number of cycles that the processor is …\nSPI0\nSPI1\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nUnchecked version of <code>Peripherals::take</code>\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nSteal an instance of this peripheral\nUnchecked version of <code>Peripherals::take</code>.\nInitiate a system reset request to reset the MCU\nRegister block for various chip control signals\nSYSINFO\nReturns all the core peripherals <em>once</em>\nTestbench manager. Allows the programmer to know what …\nControls time and alarms time is a 64 bit value indicating …\nUART0\nUART1\nRemoves the software lock on the DWT\nEnables <code>interrupt</code>\nClears <code>interrupt</code>’s pending state\nDPRAM layout for USB device.\nUSB FS/LS controller device registers\nReturns the active exception number\ncontrol and status for on-chip voltage regulator and chip …\nWATCHDOG\nQSPI flash execute-in-place block\nDW_apb_ssi has the following features:\nControls the crystal oscillator\nCS (rw) register accessor: ADC Control and Status\nDIV (rw) register accessor: Clock divider. If non-zero, …\nFCS (rw) register accessor: FIFO control and status\nFIFO (r) register accessor: Conversion result FIFO\nINTE (rw) register accessor: Interrupt Enable\nINTF (rw) register accessor: Interrupt Force\nINTR (r) register accessor: Raw Interrupts\nINTS (r) register accessor: Interrupt status after masking …\nRESULT (r) register accessor: Result of most recent ADC …\nRegister block\nADC Control and Status\n0x00 - ADC Control and Status\nClock divider. If non-zero, CS_START_MANY will start …\n0x10 - Clock divider. If non-zero, CS_START_MANY will …\nFIFO control and status\n0x08 - FIFO control and status\nConversion result FIFO\n0x0c - Conversion result FIFO\nReturns the argument unchanged.\nInterrupt Enable\n0x18 - Interrupt Enable\nInterrupt Force\n0x1c - Interrupt Force\nCalls <code>U::from(self)</code>.\nRaw Interrupts\n0x14 - Raw Interrupts\nInterrupt status after masking &amp; forcing\n0x20 - Interrupt status after masking &amp; forcing\nResult of most recent ADC conversion\n0x04 - Result of most recent ADC conversion\nField <code>AINSEL</code> reader - Select analog mux input. Updated …\nField <code>AINSEL</code> writer - Select analog mux input. Updated …\nADC Control and Status\nField <code>EN</code> reader - Power on ADC and enable its clock. 1 - …\nField <code>EN</code> writer - Power on ADC and enable its clock. 1 - …\nField <code>ERR</code> reader - The most recent ADC conversion …\nField <code>ERR_STICKY</code> reader - Some past ADC conversion …\nField <code>ERR_STICKY</code> writer - Some past ADC conversion …\nRegister <code>CS</code> reader\nField <code>READY</code> reader - 1 if the ADC is ready to start a new …\nField <code>RROBIN</code> reader - Round-robin sampling. 1 bit per …\nField <code>RROBIN</code> writer - Round-robin sampling. 1 bit per …\nField <code>START_MANY</code> reader - Continuously perform conversions …\nField <code>START_MANY</code> writer - Continuously perform conversions …\nField <code>START_ONCE</code> reader - Start a single conversion. …\nField <code>START_ONCE</code> writer - Start a single conversion. …\nField <code>TS_EN</code> reader - Power on temperature sensor. 1 - …\nField <code>TS_EN</code> writer - Power on temperature sensor. 1 - …\nRegister <code>CS</code> writer\nBits 12:14 - Select analog mux input. Updated …\nBits 12:14 - Select analog mux input. Updated …\nWrites raw bits to the register.\nBit 0 - Power on ADC and enable its clock. 1 - enabled. 0 …\nBit 0 - Power on ADC and enable its clock. 1 - enabled. 0 …\nBit 9 - The most recent ADC conversion encountered an …\nBit 10 - Some past ADC conversion encountered an error. …\nBit 10 - Some past ADC conversion encountered an error. …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBit 8 - 1 if the ADC is ready to start a new conversion. …\nBits 16:20 - Round-robin sampling. 1 bit per channel. Set …\nBits 16:20 - Round-robin sampling. 1 bit per channel. Set …\nBit 3 - Continuously perform conversions whilst this bit …\nBit 3 - Continuously perform conversions whilst this bit …\nBit 2 - Start a single conversion. Self-clearing. Ignored …\nBit 2 - Start a single conversion. Self-clearing. Ignored …\nBit 1 - Power on temperature sensor. 1 - enabled. 0 - …\nBit 1 - Power on temperature sensor. 1 - enabled. 0 - …\nClock divider. If non-zero, CS_START_MANY will start …\nField <code>FRAC</code> reader - Fractional part of clock divisor. …\nField <code>FRAC</code> writer - Fractional part of clock divisor. …\nField <code>INT</code> reader - Integer part of clock divisor.\nField <code>INT</code> writer - Integer part of clock divisor.\nRegister <code>DIV</code> reader\nRegister <code>DIV</code> writer\nWrites raw bits to the register.\nBits 0:7 - Fractional part of clock divisor. First-order …\nBits 0:7 - Fractional part of clock divisor. First-order …\nReturns the argument unchanged.\nBits 8:23 - Integer part of clock divisor.\nBits 8:23 - Integer part of clock divisor.\nCalls <code>U::from(self)</code>.\nField <code>DREQ_EN</code> reader - If 1: assert DMA requests when FIFO …\nField <code>DREQ_EN</code> writer - If 1: assert DMA requests when FIFO …\nField <code>EMPTY</code> reader -\nField <code>EN</code> reader - If 1: write result to the FIFO after …\nField <code>EN</code> writer - If 1: write result to the FIFO after …\nField <code>ERR</code> reader - If 1: conversion error bit appears in …\nField <code>ERR</code> writer - If 1: conversion error bit appears in …\nFIFO control and status\nField <code>FULL</code> reader -\nField <code>LEVEL</code> reader - The number of conversion results …\nField <code>OVER</code> reader - 1 if the FIFO has been overflowed. …\nField <code>OVER</code> writer - 1 if the FIFO has been overflowed. …\nRegister <code>FCS</code> reader\nField <code>SHIFT</code> reader - If 1: FIFO results are right-shifted …\nField <code>SHIFT</code> writer - If 1: FIFO results are right-shifted …\nField <code>THRESH</code> reader - DREQ/IRQ asserted when level &gt;= …\nField <code>THRESH</code> writer - DREQ/IRQ asserted when level &gt;= …\nField <code>UNDER</code> reader - 1 if the FIFO has been underflowed. …\nField <code>UNDER</code> writer - 1 if the FIFO has been underflowed. …\nRegister <code>FCS</code> writer\nWrites raw bits to the register.\nBit 3 - If 1: assert DMA requests when FIFO contains data\nBit 3 - If 1: assert DMA requests when FIFO contains data\nBit 8\nBit 0 - If 1: write result to the FIFO after each …\nBit 0 - If 1: write result to the FIFO after each …\nBit 2 - If 1: conversion error bit appears in the FIFO …\nBit 2 - If 1: conversion error bit appears in the FIFO …\nReturns the argument unchanged.\nBit 9\nCalls <code>U::from(self)</code>.\nBits 16:19 - The number of conversion results currently …\nBit 11 - 1 if the FIFO has been overflowed. Write 1 to …\nBit 11 - 1 if the FIFO has been overflowed. Write 1 to …\nBit 1 - If 1: FIFO results are right-shifted to be one …\nBit 1 - If 1: FIFO results are right-shifted to be one …\nBits 24:27 - DREQ/IRQ asserted when level &gt;= threshold\nBits 24:27 - DREQ/IRQ asserted when level &gt;= threshold\nBit 10 - 1 if the FIFO has been underflowed. Write 1 to …\nBit 10 - 1 if the FIFO has been underflowed. Write 1 to …\nField <code>ERR</code> reader - 1 if this particular sample experienced …\nConversion result FIFO\nRegister <code>FIFO</code> reader\nField <code>VAL</code> reader -\nBit 15 - 1 if this particular sample experienced a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBits 0:11\nField <code>FIFO</code> reader - Triggered when the sample FIFO reaches …\nField <code>FIFO</code> writer - Triggered when the sample FIFO reaches …\nInterrupt Enable\nRegister <code>INTE</code> reader\nRegister <code>INTE</code> writer\nWrites raw bits to the register.\nBit 0 - Triggered when the sample FIFO reaches a certain …\nBit 0 - Triggered when the sample FIFO reaches a certain …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>FIFO</code> reader - Triggered when the sample FIFO reaches …\nField <code>FIFO</code> writer - Triggered when the sample FIFO reaches …\nInterrupt Force\nRegister <code>INTF</code> reader\nRegister <code>INTF</code> writer\nWrites raw bits to the register.\nBit 0 - Triggered when the sample FIFO reaches a certain …\nBit 0 - Triggered when the sample FIFO reaches a certain …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>FIFO</code> reader - Triggered when the sample FIFO reaches …\nRaw Interrupts\nRegister <code>INTR</code> reader\nBit 0 - Triggered when the sample FIFO reaches a certain …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>FIFO</code> reader - Triggered when the sample FIFO reaches …\nInterrupt status after masking &amp; forcing\nRegister <code>INTS</code> reader\nBit 0 - Triggered when the sample FIFO reaches a certain …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRegister <code>RESULT</code> reader\nField <code>RESULT</code> reader -\nResult of most recent ADC conversion\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBits 0:11\nBUS_PRIORITY (rw) register accessor: Set the priority of …\nBUS_PRIORITY_ACK (r) register accessor: Bus priority …\nPERFCTR0 (rw) register accessor: Bus fabric performance …\nPERFCTR1 (rw) register accessor: Bus fabric performance …\nPERFCTR2 (rw) register accessor: Bus fabric performance …\nPERFCTR3 (rw) register accessor: Bus fabric performance …\nPERFSEL0 (rw) register accessor: Bus fabric performance …\nPERFSEL1 (rw) register accessor: Bus fabric performance …\nPERFSEL2 (rw) register accessor: Bus fabric performance …\nPERFSEL3 (rw) register accessor: Bus fabric performance …\nRegister block\nSet the priority of each master for bus arbitration.\n0x00 - Set the priority of each master for bus arbitration.\nBus priority acknowledge\n0x04 - Bus priority acknowledge\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBus fabric performance counter 0\n0x08 - Bus fabric performance counter 0\nBus fabric performance counter 1\n0x10 - Bus fabric performance counter 1\nBus fabric performance counter 2\n0x18 - Bus fabric performance counter 2\nBus fabric performance counter 3\n0x20 - Bus fabric performance counter 3\nBus fabric performance event select for PERFCTR0\n0x0c - Bus fabric performance event select for PERFCTR0\nBus fabric performance event select for PERFCTR1\n0x14 - Bus fabric performance event select for PERFCTR1\nBus fabric performance event select for PERFCTR2\n0x1c - Bus fabric performance event select for PERFCTR2\nBus fabric performance event select for PERFCTR3\n0x24 - Bus fabric performance event select for PERFCTR3\nSet the priority of each master for bus arbitration.\nField <code>DMA_R</code> reader - 0 - low priority, 1 - high priority\nField <code>DMA_R</code> writer - 0 - low priority, 1 - high priority\nField <code>DMA_W</code> reader - 0 - low priority, 1 - high priority\nField <code>DMA_W</code> writer - 0 - low priority, 1 - high priority\nField <code>PROC0</code> reader - 0 - low priority, 1 - high priority\nField <code>PROC0</code> writer - 0 - low priority, 1 - high priority\nField <code>PROC1</code> reader - 0 - low priority, 1 - high priority\nField <code>PROC1</code> writer - 0 - low priority, 1 - high priority\nRegister <code>BUS_PRIORITY</code> reader\nRegister <code>BUS_PRIORITY</code> writer\nWrites raw bits to the register.\nBit 8 - 0 - low priority, 1 - high priority\nBit 8 - 0 - low priority, 1 - high priority\nBit 12 - 0 - low priority, 1 - high priority\nBit 12 - 0 - low priority, 1 - high priority\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBit 0 - 0 - low priority, 1 - high priority\nBit 0 - 0 - low priority, 1 - high priority\nBit 4 - 0 - low priority, 1 - high priority\nBit 4 - 0 - low priority, 1 - high priority\nField <code>BUS_PRIORITY_ACK</code> reader - Goes to 1 once all …\nBus priority acknowledge\nRegister <code>BUS_PRIORITY_ACK</code> reader\nBit 0 - Goes to 1 once all arbiters have registered the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>PERFCTR0</code> reader - Busfabric saturating performance …\nBus fabric performance counter 0\nField <code>PERFCTR0</code> writer - Busfabric saturating performance …\nRegister <code>PERFCTR0</code> reader\nRegister <code>PERFCTR0</code> writer\nWrites raw bits to the register.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBits 0:23 - Busfabric saturating performance counter 0 …\nBits 0:23 - Busfabric saturating performance counter 0 …\nField <code>PERFCTR1</code> reader - Busfabric saturating performance …\nBus fabric performance counter 1\nField <code>PERFCTR1</code> writer - Busfabric saturating performance …\nRegister <code>PERFCTR1</code> reader\nRegister <code>PERFCTR1</code> writer\nWrites raw bits to the register.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBits 0:23 - Busfabric saturating performance counter 1 …\nBits 0:23 - Busfabric saturating performance counter 1 …\nField <code>PERFCTR2</code> reader - Busfabric saturating performance …\nBus fabric performance counter 2\nField <code>PERFCTR2</code> writer - Busfabric saturating performance …\nRegister <code>PERFCTR2</code> reader\nRegister <code>PERFCTR2</code> writer\nWrites raw bits to the register.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBits 0:23 - Busfabric saturating performance counter 2 …\nBits 0:23 - Busfabric saturating performance counter 2 …\nField <code>PERFCTR3</code> reader - Busfabric saturating performance …\nBus fabric performance counter 3\nField <code>PERFCTR3</code> writer - Busfabric saturating performance …\nRegister <code>PERFCTR3</code> reader\nRegister <code>PERFCTR3</code> writer\nWrites raw bits to the register.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBits 0:23 - Busfabric saturating performance counter 3 …\nBits 0:23 - Busfabric saturating performance counter 3 …\n1: <code>1</code>\n0: <code>0</code>\n3: <code>11</code>\n2: <code>10</code>\nSelect an event for PERFCTR0. Count either contested …\nField <code>PERFSEL0</code> reader - Select an event for PERFCTR0. …\nBus fabric performance event select for PERFCTR0\nField <code>PERFSEL0</code> writer - Select an event for PERFCTR0. …\nRegister <code>PERFSEL0</code> reader\n19: <code>10011</code>\n18: <code>10010</code>\n15: <code>1111</code>\n14: <code>1110</code>\n13: <code>1101</code>\n12: <code>1100</code>\n11: <code>1011</code>\n10: <code>1010</code>\n9: <code>1001</code>\n8: <code>1000</code>\n7: <code>111</code>\n6: <code>110</code>\n5: <code>101</code>\n4: <code>100</code>\nRegister <code>PERFSEL0</code> writer\n17: <code>10001</code>\n16: <code>10000</code>\n<code>1</code>\n<code>0</code>\nWrites raw bits to the register.\n<code>11</code>\n<code>10</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>1</code>\n<code>0</code>\n<code>11</code>\n<code>10</code>\n<code>10011</code>\n<code>10010</code>\n<code>1111</code>\n<code>1110</code>\n<code>1101</code>\n<code>1100</code>\n<code>1011</code>\n<code>1010</code>\n<code>1001</code>\n<code>1000</code>\n<code>111</code>\n<code>110</code>\n<code>101</code>\n<code>100</code>\n<code>10001</code>\n<code>10000</code>\nBits 0:4 - Select an event for PERFCTR0. Count either …\nBits 0:4 - Select an event for PERFCTR0. Count either …\n<code>10011</code>\n<code>10010</code>\n<code>1111</code>\n<code>1110</code>\n<code>1101</code>\n<code>1100</code>\n<code>1011</code>\n<code>1010</code>\n<code>1001</code>\n<code>1000</code>\n<code>111</code>\n<code>110</code>\n<code>101</code>\n<code>100</code>\nGet enumerated values variant\n<code>10001</code>\n<code>10000</code>\n1: <code>1</code>\n0: <code>0</code>\n3: <code>11</code>\n2: <code>10</code>\nSelect an event for PERFCTR1. Count either contested …\nField <code>PERFSEL1</code> reader - Select an event for PERFCTR1. …\nBus fabric performance event select for PERFCTR1\nField <code>PERFSEL1</code> writer - Select an event for PERFCTR1. …\nRegister <code>PERFSEL1</code> reader\n19: <code>10011</code>\n18: <code>10010</code>\n15: <code>1111</code>\n14: <code>1110</code>\n13: <code>1101</code>\n12: <code>1100</code>\n11: <code>1011</code>\n10: <code>1010</code>\n9: <code>1001</code>\n8: <code>1000</code>\n7: <code>111</code>\n6: <code>110</code>\n5: <code>101</code>\n4: <code>100</code>\nRegister <code>PERFSEL1</code> writer\n17: <code>10001</code>\n16: <code>10000</code>\n<code>1</code>\n<code>0</code>\nWrites raw bits to the register.\n<code>11</code>\n<code>10</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>1</code>\n<code>0</code>\n<code>11</code>\n<code>10</code>\n<code>10011</code>\n<code>10010</code>\n<code>1111</code>\n<code>1110</code>\n<code>1101</code>\n<code>1100</code>\n<code>1011</code>\n<code>1010</code>\n<code>1001</code>\n<code>1000</code>\n<code>111</code>\n<code>110</code>\n<code>101</code>\n<code>100</code>\n<code>10001</code>\n<code>10000</code>\nBits 0:4 - Select an event for PERFCTR1. Count either …\nBits 0:4 - Select an event for PERFCTR1. Count either …\n<code>10011</code>\n<code>10010</code>\n<code>1111</code>\n<code>1110</code>\n<code>1101</code>\n<code>1100</code>\n<code>1011</code>\n<code>1010</code>\n<code>1001</code>\n<code>1000</code>\n<code>111</code>\n<code>110</code>\n<code>101</code>\n<code>100</code>\nGet enumerated values variant\n<code>10001</code>\n<code>10000</code>\n1: <code>1</code>\n0: <code>0</code>\n3: <code>11</code>\n2: <code>10</code>\nSelect an event for PERFCTR2. Count either contested …\nField <code>PERFSEL2</code> reader - Select an event for PERFCTR2. …\nBus fabric performance event select for PERFCTR2\nField <code>PERFSEL2</code> writer - Select an event for PERFCTR2. …\nRegister <code>PERFSEL2</code> reader\n19: <code>10011</code>\n18: <code>10010</code>\n15: <code>1111</code>\n14: <code>1110</code>\n13: <code>1101</code>\n12: <code>1100</code>\n11: <code>1011</code>\n10: <code>1010</code>\n9: <code>1001</code>\n8: <code>1000</code>\n7: <code>111</code>\n6: <code>110</code>\n5: <code>101</code>\n4: <code>100</code>\nRegister <code>PERFSEL2</code> writer\n17: <code>10001</code>\n16: <code>10000</code>\n<code>1</code>\n<code>0</code>\nWrites raw bits to the register.\n<code>11</code>\n<code>10</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>1</code>\n<code>0</code>\n<code>11</code>\n<code>10</code>\n<code>10011</code>\n<code>10010</code>\n<code>1111</code>\n<code>1110</code>\n<code>1101</code>\n<code>1100</code>\n<code>1011</code>\n<code>1010</code>\n<code>1001</code>\n<code>1000</code>\n<code>111</code>\n<code>110</code>\n<code>101</code>\n<code>100</code>\n<code>10001</code>\n<code>10000</code>\nBits 0:4 - Select an event for PERFCTR2. Count either …\nBits 0:4 - Select an event for PERFCTR2. Count either …\n<code>10011</code>\n<code>10010</code>\n<code>1111</code>\n<code>1110</code>\n<code>1101</code>\n<code>1100</code>\n<code>1011</code>\n<code>1010</code>\n<code>1001</code>\n<code>1000</code>\n<code>111</code>\n<code>110</code>\n<code>101</code>\n<code>100</code>\nGet enumerated values variant\n<code>10001</code>\n<code>10000</code>\n1: <code>1</code>\n0: <code>0</code>\n3: <code>11</code>\n2: <code>10</code>\nSelect an event for PERFCTR3. Count either contested …\nField <code>PERFSEL3</code> reader - Select an event for PERFCTR3. …\nBus fabric performance event select for PERFCTR3\nField <code>PERFSEL3</code> writer - Select an event for PERFCTR3. …\nRegister <code>PERFSEL3</code> reader\n19: <code>10011</code>\n18: <code>10010</code>\n15: <code>1111</code>\n14: <code>1110</code>\n13: <code>1101</code>\n12: <code>1100</code>\n11: <code>1011</code>\n10: <code>1010</code>\n9: <code>1001</code>\n8: <code>1000</code>\n7: <code>111</code>\n6: <code>110</code>\n5: <code>101</code>\n4: <code>100</code>\nRegister <code>PERFSEL3</code> writer\n17: <code>10001</code>\n16: <code>10000</code>\n<code>1</code>\n<code>0</code>\nWrites raw bits to the register.\n<code>11</code>\n<code>10</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>1</code>\n<code>0</code>\n<code>11</code>\n<code>10</code>\n<code>10011</code>\n<code>10010</code>\n<code>1111</code>\n<code>1110</code>\n<code>1101</code>\n<code>1100</code>\n<code>1011</code>\n<code>1010</code>\n<code>1001</code>\n<code>1000</code>\n<code>111</code>\n<code>110</code>\n<code>101</code>\n<code>100</code>\n<code>10001</code>\n<code>10000</code>\nBits 0:4 - Select an event for PERFCTR3. Count either …\nBits 0:4 - Select an event for PERFCTR3. Count either …\n<code>10011</code>\n<code>10010</code>\n<code>1111</code>\n<code>1110</code>\n<code>1101</code>\n<code>1100</code>\n<code>1011</code>\n<code>1010</code>\n<code>1001</code>\n<code>1000</code>\n<code>111</code>\n<code>110</code>\n<code>101</code>\n<code>100</code>\nGet enumerated values variant\n<code>10001</code>\n<code>10000</code>\nCLK_ADC_CTRL (rw) register accessor: Clock control, can be …\nCLK_ADC_DIV (rw) register accessor: Clock divisor, can be …\nCLK_ADC_SELECTED (r) register accessor: Indicates which …\nCLK_GPOUT0_CTRL (rw) register accessor: Clock control, can …\nCLK_GPOUT0_DIV (rw) register accessor: Clock divisor, can …\nCLK_GPOUT0_SELECTED (r) register accessor: Indicates which …\nCLK_GPOUT1_CTRL (rw) register accessor: Clock control, can …\nCLK_GPOUT1_DIV (rw) register accessor: Clock divisor, can …\nCLK_GPOUT1_SELECTED (r) register accessor: Indicates which …\nCLK_GPOUT2_CTRL (rw) register accessor: Clock control, can …\nCLK_GPOUT2_DIV (rw) register accessor: Clock divisor, can …\nCLK_GPOUT2_SELECTED (r) register accessor: Indicates which …\nCLK_GPOUT3_CTRL (rw) register accessor: Clock control, can …\nCLK_GPOUT3_DIV (rw) register accessor: Clock divisor, can …\nCLK_GPOUT3_SELECTED (r) register accessor: Indicates which …\nCLK_PERI_CTRL (rw) register accessor: Clock control, can …\nCLK_PERI_SELECTED (r) register accessor: Indicates which …\nCLK_REF_CTRL (rw) register accessor: Clock control, can be …\nCLK_REF_DIV (rw) register accessor: Clock divisor, can be …\nCLK_REF_SELECTED (r) register accessor: Indicates which …\nCLK_RTC_CTRL (rw) register accessor: Clock control, can be …\nCLK_RTC_DIV (rw) register accessor: Clock divisor, can be …\nCLK_RTC_SELECTED (r) register accessor: Indicates which …\nCLK_SYS_CTRL (rw) register accessor: Clock control, can be …\nCLK_SYS_DIV (rw) register accessor: Clock divisor, can be …\nCLK_SYS_RESUS_CTRL (rw) register accessor:\nCLK_SYS_RESUS_STATUS (r) register accessor:\nCLK_SYS_SELECTED (r) register accessor: Indicates which …\nCLK_USB_CTRL (rw) register accessor: Clock control, can be …\nCLK_USB_DIV (rw) register accessor: Clock divisor, can be …\nCLK_USB_SELECTED (r) register accessor: Indicates which …\nENABLED0 (r) register accessor: indicates the state of the …\nENABLED1 (r) register accessor: indicates the state of the …\nFC0_DELAY (rw) register accessor: Delays the start of …\nFC0_INTERVAL (rw) register accessor: The test interval is …\nFC0_MAX_KHZ (rw) register accessor: Maximum pass frequency …\nFC0_MIN_KHZ (rw) register accessor: Minimum pass frequency …\nFC0_REF_KHZ (rw) register accessor: Reference clock …\nFC0_RESULT (r) register accessor: Result of frequency …\nFC0_SRC (rw) register accessor: Clock sent to frequency …\nFC0_STATUS (r) register accessor: Frequency counter status\nINTE (rw) register accessor: Interrupt Enable\nINTF (rw) register accessor: Interrupt Force\nINTR (r) register accessor: Raw Interrupts\nINTS (r) register accessor: Interrupt status after masking …\nRegister block\nSLEEP_EN0 (rw) register accessor: enable clock in sleep …\nSLEEP_EN1 (rw) register accessor: enable clock in sleep …\nWAKE_EN0 (rw) register accessor: enable clock in wake mode\nWAKE_EN1 (rw) register accessor: enable clock in wake mode\nClock control, can be changed on-the-fly (except for …\n0x60 - Clock control, can be changed on-the-fly (except …\nClock divisor, can be changed on-the-fly\n0x64 - Clock divisor, can be changed on-the-fly\nIndicates which SRC is currently selected by the …\n0x68 - Indicates which SRC is currently selected by the …\nClock control, can be changed on-the-fly (except for …\n0x00 - Clock control, can be changed on-the-fly (except …\nClock divisor, can be changed on-the-fly\n0x04 - Clock divisor, can be changed on-the-fly\nIndicates which SRC is currently selected by the …\n0x08 - Indicates which SRC is currently selected by the …\nClock control, can be changed on-the-fly (except for …\n0x0c - Clock control, can be changed on-the-fly (except …\nClock divisor, can be changed on-the-fly\n0x10 - Clock divisor, can be changed on-the-fly\nIndicates which SRC is currently selected by the …\n0x14 - Indicates which SRC is currently selected by the …\nClock control, can be changed on-the-fly (except for …\n0x18 - Clock control, can be changed on-the-fly (except …\nClock divisor, can be changed on-the-fly\n0x1c - Clock divisor, can be changed on-the-fly\nIndicates which SRC is currently selected by the …\n0x20 - Indicates which SRC is currently selected by the …\nClock control, can be changed on-the-fly (except for …\n0x24 - Clock control, can be changed on-the-fly (except …\nClock divisor, can be changed on-the-fly\n0x28 - Clock divisor, can be changed on-the-fly\nIndicates which SRC is currently selected by the …\n0x2c - Indicates which SRC is currently selected by the …\nClock control, can be changed on-the-fly (except for …\n0x48 - Clock control, can be changed on-the-fly (except …\nIndicates which SRC is currently selected by the …\n0x50 - Indicates which SRC is currently selected by the …\nClock control, can be changed on-the-fly (except for …\n0x30 - Clock control, can be changed on-the-fly (except …\nClock divisor, can be changed on-the-fly\n0x34 - Clock divisor, can be changed on-the-fly\nIndicates which SRC is currently selected by the …\n0x38 - Indicates which SRC is currently selected by the …\nClock control, can be changed on-the-fly (except for …\n0x6c - Clock control, can be changed on-the-fly (except …\nClock divisor, can be changed on-the-fly\n0x70 - Clock divisor, can be changed on-the-fly\nIndicates which SRC is currently selected by the …\n0x74 - Indicates which SRC is currently selected by the …\nClock control, can be changed on-the-fly (except for …\n0x3c - Clock control, can be changed on-the-fly (except …\nClock divisor, can be changed on-the-fly\n0x40 - Clock divisor, can be changed on-the-fly\n0x78 -\n0x7c -\nIndicates which SRC is currently selected by the …\n0x44 - Indicates which SRC is currently selected by the …\nClock control, can be changed on-the-fly (except for …\n0x54 - Clock control, can be changed on-the-fly (except …\nClock divisor, can be changed on-the-fly\n0x58 - Clock divisor, can be changed on-the-fly\nIndicates which SRC is currently selected by the …\n0x5c - Indicates which SRC is currently selected by the …\nindicates the state of the clock enable\n0xb0 - indicates the state of the clock enable\nindicates the state of the clock enable\n0xb4 - indicates the state of the clock enable\nDelays the start of frequency counting to allow the mux to …\n0x8c - Delays the start of frequency counting to allow the …\nThe test interval is 0.98us * 2<strong>interval, but let’s call </strong>…\n0x90 - The test interval is 0.98us * 2<strong>interval, but let’</strong>…\nMaximum pass frequency in kHz. This is optional. Set to …\n0x88 - Maximum pass frequency in kHz. This is optional. …\nMinimum pass frequency in kHz. This is optional. Set to 0 …\n0x84 - Minimum pass frequency in kHz. This is optional. …\nReference clock frequency in kHz\n0x80 - Reference clock frequency in kHz\nResult of frequency measurement, only valid when …\n0x9c - Result of frequency measurement, only valid when …\nClock sent to frequency counter, set to 0 when not required\n0x94 - Clock sent to frequency counter, set to 0 when not …\nFrequency counter status\n0x98 - Frequency counter status\nReturns the argument unchanged.\nInterrupt Enable\n0xbc - Interrupt Enable\nInterrupt Force\n0xc0 - Interrupt Force\nCalls <code>U::from(self)</code>.\nRaw Interrupts\n0xb8 - Raw Interrupts\nInterrupt status after masking &amp; forcing\n0xc4 - Interrupt status after masking &amp; forcing\nenable clock in sleep mode\n0xa8 - enable clock in sleep mode\nenable clock in sleep mode\n0xac - enable clock in sleep mode\nenable clock in wake mode\n0xa0 - enable clock in wake mode\nenable clock in wake mode\n0xa4 - enable clock in wake mode\nSelects the auxiliary clock source, will glitch when …\nField <code>AUXSRC</code> reader - Selects the auxiliary clock source, …\nField <code>AUXSRC</code> writer - Selects the auxiliary clock source, …\n4: <code>100</code>\n5: <code>101</code>\n1: <code>1</code>\n0: <code>0</code>\nClock control, can be changed on-the-fly (except for …\nField <code>ENABLE</code> reader - Starts and stops the clock generator …\nField <code>ENABLE</code> writer - Starts and stops the clock generator …\nField <code>KILL</code> reader - Asynchronously kills the clock …\nField <code>KILL</code> writer - Asynchronously kills the clock …\nField <code>NUDGE</code> reader - An edge on this signal shifts the …\nField <code>NUDGE</code> writer - An edge on this signal shifts the …\nField <code>PHASE</code> reader - This delays the enable signal by up …\nField <code>PHASE</code> writer - This delays the enable signal by up …\nRegister <code>CLK_ADC_CTRL</code> reader\n2: <code>10</code>\nRegister <code>CLK_ADC_CTRL</code> writer\n3: <code>11</code>\nBits 5:7 - Selects the auxiliary clock source, will glitch …\nBits 5:7 - Selects the auxiliary clock source, will glitch …\nWrites raw bits to the register.\n<code>100</code>\n<code>101</code>\n<code>1</code>\n<code>0</code>\nBit 11 - Starts and stops the clock generator cleanly\nBit 11 - Starts and stops the clock generator cleanly\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>100</code>\n<code>101</code>\n<code>1</code>\n<code>0</code>\n<code>10</code>\n<code>11</code>\nBit 10 - Asynchronously kills the clock generator\nBit 10 - Asynchronously kills the clock generator\nBit 20 - An edge on this signal shifts the phase of the …\nBit 20 - An edge on this signal shifts the phase of the …\nBits 16:17 - This delays the enable signal by up to 3 …\nBits 16:17 - This delays the enable signal by up to 3 …\n<code>10</code>\nGet enumerated values variant\n<code>11</code>\nClock divisor, can be changed on-the-fly\nField <code>INT</code> reader - Integer component of the divisor, 0 -&gt; …\nField <code>INT</code> writer - Integer component of the divisor, 0 -&gt; …\nRegister <code>CLK_ADC_DIV</code> reader\nRegister <code>CLK_ADC_DIV</code> writer\nWrites raw bits to the register.\nReturns the argument unchanged.\nBits 8:9 - Integer component of the divisor, 0 -&gt; divide …\nBits 8:9 - Integer component of the divisor, 0 -&gt; divide …\nCalls <code>U::from(self)</code>.\nIndicates which SRC is currently selected by the …\nRegister <code>CLK_ADC_SELECTED</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSelects the auxiliary clock source, will glitch when …\nField <code>AUXSRC</code> reader - Selects the auxiliary clock source, …\nField <code>AUXSRC</code> writer - Selects the auxiliary clock source, …\n1: <code>1</code>\n2: <code>10</code>\n0: <code>0</code>\n3: <code>11</code>\n8: <code>1000</code>\nClock control, can be changed on-the-fly (except for …\n10: <code>1010</code>\n9: <code>1001</code>\n6: <code>110</code>\n7: <code>111</code>\nField <code>DC50</code> reader - Enables duty cycle correction for odd …\nField <code>DC50</code> writer - Enables duty cycle correction for odd …\nField <code>ENABLE</code> reader - Starts and stops the clock generator …\nField <code>ENABLE</code> writer - Starts and stops the clock generator …\nField <code>KILL</code> reader - Asynchronously kills the clock …\nField <code>KILL</code> writer - Asynchronously kills the clock …\nField <code>NUDGE</code> reader - An edge on this signal shifts the …\nField <code>NUDGE</code> writer - An edge on this signal shifts the …\nField <code>PHASE</code> reader - This delays the enable signal by up …\nField <code>PHASE</code> writer - This delays the enable signal by up …\nRegister <code>CLK_GPOUT0_CTRL</code> reader\n4: <code>100</code>\nRegister <code>CLK_GPOUT0_CTRL</code> writer\n5: <code>101</code>\nBits 5:8 - Selects the auxiliary clock source, will glitch …\nBits 5:8 - Selects the auxiliary clock source, will glitch …\nWrites raw bits to the register.\n<code>1000</code>\n<code>1010</code>\n<code>1001</code>\n<code>110</code>\n<code>111</code>\n<code>1</code>\n<code>10</code>\n<code>0</code>\n<code>11</code>\nBit 12 - Enables duty cycle correction for odd divisors\nBit 12 - Enables duty cycle correction for odd divisors\nBit 11 - Starts and stops the clock generator cleanly\nBit 11 - Starts and stops the clock generator cleanly\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>1000</code>\n<code>1010</code>\n<code>1001</code>\n<code>110</code>\n<code>111</code>\n<code>1</code>\n<code>10</code>\n<code>0</code>\n<code>11</code>\n<code>100</code>\n<code>101</code>\nBit 10 - Asynchronously kills the clock generator\nBit 10 - Asynchronously kills the clock generator\nBit 20 - An edge on this signal shifts the phase of the …\nBit 20 - An edge on this signal shifts the phase of the …\nBits 16:17 - This delays the enable signal by up to 3 …\nBits 16:17 - This delays the enable signal by up to 3 …\n<code>100</code>\nGet enumerated values variant\n<code>101</code>\nClock divisor, can be changed on-the-fly\nField <code>FRAC</code> reader - Fractional component of the divisor\nField <code>FRAC</code> writer - Fractional component of the divisor\nField <code>INT</code> reader - Integer component of the divisor, 0 -&gt; …\nField <code>INT</code> writer - Integer component of the divisor, 0 -&gt; …\nRegister <code>CLK_GPOUT0_DIV</code> reader\nRegister <code>CLK_GPOUT0_DIV</code> writer\nWrites raw bits to the register.\nBits 0:7 - Fractional component of the divisor\nBits 0:7 - Fractional component of the divisor\nReturns the argument unchanged.\nBits 8:31 - Integer component of the divisor, 0 -&gt; divide …\nBits 8:31 - Integer component of the divisor, 0 -&gt; divide …\nCalls <code>U::from(self)</code>.\nIndicates which SRC is currently selected by the …\nRegister <code>CLK_GPOUT0_SELECTED</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSelects the auxiliary clock source, will glitch when …\nField <code>AUXSRC</code> reader - Selects the auxiliary clock source, …\nField <code>AUXSRC</code> writer - Selects the auxiliary clock source, …\n1: <code>1</code>\n2: <code>10</code>\n0: <code>0</code>\n3: <code>11</code>\n8: <code>1000</code>\nClock control, can be changed on-the-fly (except for …\n10: <code>1010</code>\n9: <code>1001</code>\n6: <code>110</code>\n7: <code>111</code>\nField <code>DC50</code> reader - Enables duty cycle correction for odd …\nField <code>DC50</code> writer - Enables duty cycle correction for odd …\nField <code>ENABLE</code> reader - Starts and stops the clock generator …\nField <code>ENABLE</code> writer - Starts and stops the clock generator …\nField <code>KILL</code> reader - Asynchronously kills the clock …\nField <code>KILL</code> writer - Asynchronously kills the clock …\nField <code>NUDGE</code> reader - An edge on this signal shifts the …\nField <code>NUDGE</code> writer - An edge on this signal shifts the …\nField <code>PHASE</code> reader - This delays the enable signal by up …\nField <code>PHASE</code> writer - This delays the enable signal by up …\nRegister <code>CLK_GPOUT1_CTRL</code> reader\n4: <code>100</code>\nRegister <code>CLK_GPOUT1_CTRL</code> writer\n5: <code>101</code>\nBits 5:8 - Selects the auxiliary clock source, will glitch …\nBits 5:8 - Selects the auxiliary clock source, will glitch …\nWrites raw bits to the register.\n<code>1000</code>\n<code>1010</code>\n<code>1001</code>\n<code>110</code>\n<code>111</code>\n<code>1</code>\n<code>10</code>\n<code>0</code>\n<code>11</code>\nBit 12 - Enables duty cycle correction for odd divisors\nBit 12 - Enables duty cycle correction for odd divisors\nBit 11 - Starts and stops the clock generator cleanly\nBit 11 - Starts and stops the clock generator cleanly\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>1000</code>\n<code>1010</code>\n<code>1001</code>\n<code>110</code>\n<code>111</code>\n<code>1</code>\n<code>10</code>\n<code>0</code>\n<code>11</code>\n<code>100</code>\n<code>101</code>\nBit 10 - Asynchronously kills the clock generator\nBit 10 - Asynchronously kills the clock generator\nBit 20 - An edge on this signal shifts the phase of the …\nBit 20 - An edge on this signal shifts the phase of the …\nBits 16:17 - This delays the enable signal by up to 3 …\nBits 16:17 - This delays the enable signal by up to 3 …\n<code>100</code>\nGet enumerated values variant\n<code>101</code>\nClock divisor, can be changed on-the-fly\nField <code>FRAC</code> reader - Fractional component of the divisor\nField <code>FRAC</code> writer - Fractional component of the divisor\nField <code>INT</code> reader - Integer component of the divisor, 0 -&gt; …\nField <code>INT</code> writer - Integer component of the divisor, 0 -&gt; …\nRegister <code>CLK_GPOUT1_DIV</code> reader\nRegister <code>CLK_GPOUT1_DIV</code> writer\nWrites raw bits to the register.\nBits 0:7 - Fractional component of the divisor\nBits 0:7 - Fractional component of the divisor\nReturns the argument unchanged.\nBits 8:31 - Integer component of the divisor, 0 -&gt; divide …\nBits 8:31 - Integer component of the divisor, 0 -&gt; divide …\nCalls <code>U::from(self)</code>.\nIndicates which SRC is currently selected by the …\nRegister <code>CLK_GPOUT1_SELECTED</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSelects the auxiliary clock source, will glitch when …\nField <code>AUXSRC</code> reader - Selects the auxiliary clock source, …\nField <code>AUXSRC</code> writer - Selects the auxiliary clock source, …\n1: <code>1</code>\n2: <code>10</code>\n0: <code>0</code>\n3: <code>11</code>\n8: <code>1000</code>\nClock control, can be changed on-the-fly (except for …\n10: <code>1010</code>\n9: <code>1001</code>\n6: <code>110</code>\n7: <code>111</code>\nField <code>DC50</code> reader - Enables duty cycle correction for odd …\nField <code>DC50</code> writer - Enables duty cycle correction for odd …\nField <code>ENABLE</code> reader - Starts and stops the clock generator …\nField <code>ENABLE</code> writer - Starts and stops the clock generator …\nField <code>KILL</code> reader - Asynchronously kills the clock …\nField <code>KILL</code> writer - Asynchronously kills the clock …\nField <code>NUDGE</code> reader - An edge on this signal shifts the …\nField <code>NUDGE</code> writer - An edge on this signal shifts the …\nField <code>PHASE</code> reader - This delays the enable signal by up …\nField <code>PHASE</code> writer - This delays the enable signal by up …\nRegister <code>CLK_GPOUT2_CTRL</code> reader\n4: <code>100</code>\nRegister <code>CLK_GPOUT2_CTRL</code> writer\n5: <code>101</code>\nBits 5:8 - Selects the auxiliary clock source, will glitch …\nBits 5:8 - Selects the auxiliary clock source, will glitch …\nWrites raw bits to the register.\n<code>1000</code>\n<code>1010</code>\n<code>1001</code>\n<code>110</code>\n<code>111</code>\n<code>1</code>\n<code>10</code>\n<code>0</code>\n<code>11</code>\nBit 12 - Enables duty cycle correction for odd divisors\nBit 12 - Enables duty cycle correction for odd divisors\nBit 11 - Starts and stops the clock generator cleanly\nBit 11 - Starts and stops the clock generator cleanly\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>1000</code>\n<code>1010</code>\n<code>1001</code>\n<code>110</code>\n<code>111</code>\n<code>1</code>\n<code>10</code>\n<code>0</code>\n<code>11</code>\n<code>100</code>\n<code>101</code>\nBit 10 - Asynchronously kills the clock generator\nBit 10 - Asynchronously kills the clock generator\nBit 20 - An edge on this signal shifts the phase of the …\nBit 20 - An edge on this signal shifts the phase of the …\nBits 16:17 - This delays the enable signal by up to 3 …\nBits 16:17 - This delays the enable signal by up to 3 …\n<code>100</code>\nGet enumerated values variant\n<code>101</code>\nClock divisor, can be changed on-the-fly\nField <code>FRAC</code> reader - Fractional component of the divisor\nField <code>FRAC</code> writer - Fractional component of the divisor\nField <code>INT</code> reader - Integer component of the divisor, 0 -&gt; …\nField <code>INT</code> writer - Integer component of the divisor, 0 -&gt; …\nRegister <code>CLK_GPOUT2_DIV</code> reader\nRegister <code>CLK_GPOUT2_DIV</code> writer\nWrites raw bits to the register.\nBits 0:7 - Fractional component of the divisor\nBits 0:7 - Fractional component of the divisor\nReturns the argument unchanged.\nBits 8:31 - Integer component of the divisor, 0 -&gt; divide …\nBits 8:31 - Integer component of the divisor, 0 -&gt; divide …\nCalls <code>U::from(self)</code>.\nIndicates which SRC is currently selected by the …\nRegister <code>CLK_GPOUT2_SELECTED</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSelects the auxiliary clock source, will glitch when …\nField <code>AUXSRC</code> reader - Selects the auxiliary clock source, …\nField <code>AUXSRC</code> writer - Selects the auxiliary clock source, …\n1: <code>1</code>\n2: <code>10</code>\n0: <code>0</code>\n3: <code>11</code>\n8: <code>1000</code>\nClock control, can be changed on-the-fly (except for …\n10: <code>1010</code>\n9: <code>1001</code>\n6: <code>110</code>\n7: <code>111</code>\nField <code>DC50</code> reader - Enables duty cycle correction for odd …\nField <code>DC50</code> writer - Enables duty cycle correction for odd …\nField <code>ENABLE</code> reader - Starts and stops the clock generator …\nField <code>ENABLE</code> writer - Starts and stops the clock generator …\nField <code>KILL</code> reader - Asynchronously kills the clock …\nField <code>KILL</code> writer - Asynchronously kills the clock …\nField <code>NUDGE</code> reader - An edge on this signal shifts the …\nField <code>NUDGE</code> writer - An edge on this signal shifts the …\nField <code>PHASE</code> reader - This delays the enable signal by up …\nField <code>PHASE</code> writer - This delays the enable signal by up …\nRegister <code>CLK_GPOUT3_CTRL</code> reader\n4: <code>100</code>\nRegister <code>CLK_GPOUT3_CTRL</code> writer\n5: <code>101</code>\nBits 5:8 - Selects the auxiliary clock source, will glitch …\nBits 5:8 - Selects the auxiliary clock source, will glitch …\nWrites raw bits to the register.\n<code>1000</code>\n<code>1010</code>\n<code>1001</code>\n<code>110</code>\n<code>111</code>\n<code>1</code>\n<code>10</code>\n<code>0</code>\n<code>11</code>\nBit 12 - Enables duty cycle correction for odd divisors\nBit 12 - Enables duty cycle correction for odd divisors\nBit 11 - Starts and stops the clock generator cleanly\nBit 11 - Starts and stops the clock generator cleanly\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>1000</code>\n<code>1010</code>\n<code>1001</code>\n<code>110</code>\n<code>111</code>\n<code>1</code>\n<code>10</code>\n<code>0</code>\n<code>11</code>\n<code>100</code>\n<code>101</code>\nBit 10 - Asynchronously kills the clock generator\nBit 10 - Asynchronously kills the clock generator\nBit 20 - An edge on this signal shifts the phase of the …\nBit 20 - An edge on this signal shifts the phase of the …\nBits 16:17 - This delays the enable signal by up to 3 …\nBits 16:17 - This delays the enable signal by up to 3 …\n<code>100</code>\nGet enumerated values variant\n<code>101</code>\nClock divisor, can be changed on-the-fly\nField <code>FRAC</code> reader - Fractional component of the divisor\nField <code>FRAC</code> writer - Fractional component of the divisor\nField <code>INT</code> reader - Integer component of the divisor, 0 -&gt; …\nField <code>INT</code> writer - Integer component of the divisor, 0 -&gt; …\nRegister <code>CLK_GPOUT3_DIV</code> reader\nRegister <code>CLK_GPOUT3_DIV</code> writer\nWrites raw bits to the register.\nBits 0:7 - Fractional component of the divisor\nBits 0:7 - Fractional component of the divisor\nReturns the argument unchanged.\nBits 8:31 - Integer component of the divisor, 0 -&gt; divide …\nBits 8:31 - Integer component of the divisor, 0 -&gt; divide …\nCalls <code>U::from(self)</code>.\nIndicates which SRC is currently selected by the …\nRegister <code>CLK_GPOUT3_SELECTED</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSelects the auxiliary clock source, will glitch when …\nField <code>AUXSRC</code> reader - Selects the auxiliary clock source, …\nField <code>AUXSRC</code> writer - Selects the auxiliary clock source, …\n5: <code>101</code>\n6: <code>110</code>\n1: <code>1</code>\n2: <code>10</code>\nClock control, can be changed on-the-fly (except for …\n0: <code>0</code>\nField <code>ENABLE</code> reader - Starts and stops the clock generator …\nField <code>ENABLE</code> writer - Starts and stops the clock generator …\nField <code>KILL</code> reader - Asynchronously kills the clock …\nField <code>KILL</code> writer - Asynchronously kills the clock …\nRegister <code>CLK_PERI_CTRL</code> reader\n3: <code>11</code>\nRegister <code>CLK_PERI_CTRL</code> writer\n4: <code>100</code>\nBits 5:7 - Selects the auxiliary clock source, will glitch …\nBits 5:7 - Selects the auxiliary clock source, will glitch …\nWrites raw bits to the register.\n<code>0</code>\n<code>101</code>\n<code>110</code>\n<code>1</code>\n<code>10</code>\nBit 11 - Starts and stops the clock generator cleanly\nBit 11 - Starts and stops the clock generator cleanly\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>0</code>\n<code>101</code>\n<code>110</code>\n<code>1</code>\n<code>10</code>\n<code>11</code>\n<code>100</code>\nBit 10 - Asynchronously kills the clock generator\nBit 10 - Asynchronously kills the clock generator\n<code>11</code>\nGet enumerated values variant\n<code>100</code>\nIndicates which SRC is currently selected by the …\nRegister <code>CLK_PERI_SELECTED</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSelects the auxiliary clock source, will glitch when …\nField <code>AUXSRC</code> reader - Selects the auxiliary clock source, …\nField <code>AUXSRC</code> writer - Selects the auxiliary clock source, …\n1: <code>1</code>\n1: <code>1</code>\n2: <code>10</code>\n0: <code>0</code>\nClock control, can be changed on-the-fly (except for …\nRegister <code>CLK_REF_CTRL</code> reader\n0: <code>0</code>\nSelects the clock source glitchlessly, can be changed …\nField <code>SRC</code> reader - Selects the clock source glitchlessly, …\nField <code>SRC</code> writer - Selects the clock source glitchlessly, …\nRegister <code>CLK_REF_CTRL</code> writer\n2: <code>10</code>\nBits 5:6 - Selects the auxiliary clock source, will glitch …\nBits 5:6 - Selects the auxiliary clock source, will glitch …\nWrites raw bits to the register.\n<code>1</code>\n<code>1</code>\n<code>10</code>\n<code>0</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>1</code>\n<code>1</code>\n<code>10</code>\n<code>0</code>\n<code>0</code>\n<code>10</code>\n<code>0</code>\nBits 0:1 - Selects the clock source glitchlessly, can be …\nBits 0:1 - Selects the clock source glitchlessly, can be …\nGet enumerated values variant\nGet enumerated values variant\n<code>10</code>\nClock divisor, can be changed on-the-fly\nField <code>INT</code> reader - Integer component of the divisor, 0 -&gt; …\nField <code>INT</code> writer - Integer component of the divisor, 0 -&gt; …\nRegister <code>CLK_REF_DIV</code> reader\nRegister <code>CLK_REF_DIV</code> writer\nWrites raw bits to the register.\nReturns the argument unchanged.\nBits 8:9 - Integer component of the divisor, 0 -&gt; divide …\nBits 8:9 - Integer component of the divisor, 0 -&gt; divide …\nCalls <code>U::from(self)</code>.\nIndicates which SRC is currently selected by the …\nRegister <code>CLK_REF_SELECTED</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSelects the auxiliary clock source, will glitch when …\nField <code>AUXSRC</code> reader - Selects the auxiliary clock source, …\nField <code>AUXSRC</code> writer - Selects the auxiliary clock source, …\n4: <code>100</code>\n5: <code>101</code>\n1: <code>1</code>\n0: <code>0</code>\nClock control, can be changed on-the-fly (except for …\nField <code>ENABLE</code> reader - Starts and stops the clock generator …\nField <code>ENABLE</code> writer - Starts and stops the clock generator …\nField <code>KILL</code> reader - Asynchronously kills the clock …\nField <code>KILL</code> writer - Asynchronously kills the clock …\nField <code>NUDGE</code> reader - An edge on this signal shifts the …\nField <code>NUDGE</code> writer - An edge on this signal shifts the …\nField <code>PHASE</code> reader - This delays the enable signal by up …\nField <code>PHASE</code> writer - This delays the enable signal by up …\nRegister <code>CLK_RTC_CTRL</code> reader\n2: <code>10</code>\nRegister <code>CLK_RTC_CTRL</code> writer\n3: <code>11</code>\nBits 5:7 - Selects the auxiliary clock source, will glitch …\nBits 5:7 - Selects the auxiliary clock source, will glitch …\nWrites raw bits to the register.\n<code>100</code>\n<code>101</code>\n<code>1</code>\n<code>0</code>\nBit 11 - Starts and stops the clock generator cleanly\nBit 11 - Starts and stops the clock generator cleanly\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>100</code>\n<code>101</code>\n<code>1</code>\n<code>0</code>\n<code>10</code>\n<code>11</code>\nBit 10 - Asynchronously kills the clock generator\nBit 10 - Asynchronously kills the clock generator\nBit 20 - An edge on this signal shifts the phase of the …\nBit 20 - An edge on this signal shifts the phase of the …\nBits 16:17 - This delays the enable signal by up to 3 …\nBits 16:17 - This delays the enable signal by up to 3 …\n<code>10</code>\nGet enumerated values variant\n<code>11</code>\nClock divisor, can be changed on-the-fly\nField <code>FRAC</code> reader - Fractional component of the divisor\nField <code>FRAC</code> writer - Fractional component of the divisor\nField <code>INT</code> reader - Integer component of the divisor, 0 -&gt; …\nField <code>INT</code> writer - Integer component of the divisor, 0 -&gt; …\nRegister <code>CLK_RTC_DIV</code> reader\nRegister <code>CLK_RTC_DIV</code> writer\nWrites raw bits to the register.\nBits 0:7 - Fractional component of the divisor\nBits 0:7 - Fractional component of the divisor\nReturns the argument unchanged.\nBits 8:31 - Integer component of the divisor, 0 -&gt; divide …\nBits 8:31 - Integer component of the divisor, 0 -&gt; divide …\nCalls <code>U::from(self)</code>.\nIndicates which SRC is currently selected by the …\nRegister <code>CLK_RTC_SELECTED</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSelects the auxiliary clock source, will glitch when …\nField <code>AUXSRC</code> reader - Selects the auxiliary clock source, …\nField <code>AUXSRC</code> writer - Selects the auxiliary clock source, …\n1: <code>1</code>\n4: <code>100</code>\n5: <code>101</code>\n0: <code>0</code>\n1: <code>1</code>\n0: <code>0</code>\nClock control, can be changed on-the-fly (except for …\nRegister <code>CLK_SYS_CTRL</code> reader\n2: <code>10</code>\nSelects the clock source glitchlessly, can be changed …\nField <code>SRC</code> reader - Selects the clock source glitchlessly, …\nField <code>SRC</code> writer - Selects the clock source glitchlessly, …\nRegister <code>CLK_SYS_CTRL</code> writer\n3: <code>11</code>\nBits 5:7 - Selects the auxiliary clock source, will glitch …\nBits 5:7 - Selects the auxiliary clock source, will glitch …\nWrites raw bits to the register.\n<code>0</code>\n<code>1</code>\n<code>100</code>\n<code>101</code>\n<code>0</code>\n<code>1</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>0</code>\n<code>1</code>\n<code>100</code>\n<code>101</code>\n<code>0</code>\n<code>1</code>\n<code>10</code>\n<code>11</code>\n<code>10</code>\nBit 0 - Selects the clock source glitchlessly, can be …\nBit 0 - Selects the clock source glitchlessly, can be …\nGet enumerated values variant\nGet enumerated values variant\n<code>11</code>\nClock divisor, can be changed on-the-fly\nField <code>FRAC</code> reader - Fractional component of the divisor\nField <code>FRAC</code> writer - Fractional component of the divisor\nField <code>INT</code> reader - Integer component of the divisor, 0 -&gt; …\nField <code>INT</code> writer - Integer component of the divisor, 0 -&gt; …\nRegister <code>CLK_SYS_DIV</code> reader\nRegister <code>CLK_SYS_DIV</code> writer\nWrites raw bits to the register.\nBits 0:7 - Fractional component of the divisor\nBits 0:7 - Fractional component of the divisor\nReturns the argument unchanged.\nBits 8:31 - Integer component of the divisor, 0 -&gt; divide …\nBits 8:31 - Integer component of the divisor, 0 -&gt; divide …\nCalls <code>U::from(self)</code>.\nField <code>CLEAR</code> reader - For clearing the resus after the …\nField <code>CLEAR</code> writer - For clearing the resus after the …\nYou can <code>read</code> this register and get <code>clk_sys_resus_ctrl::R</code>.  …\nField <code>ENABLE</code> reader - Enable resus\nField <code>ENABLE</code> writer - Enable resus\nField <code>FRCE</code> reader - Force a resus, for test purposes only\nField <code>FRCE</code> writer - Force a resus, for test purposes only\nRegister <code>CLK_SYS_RESUS_CTRL</code> reader\nField <code>TIMEOUT</code> reader - This is expressed as a number of …\nField <code>TIMEOUT</code> writer - This is expressed as a number of …\nRegister <code>CLK_SYS_RESUS_CTRL</code> writer\nWrites raw bits to the register.\nBit 16 - For clearing the resus after the fault that …\nBit 16 - For clearing the resus after the fault that …\nBit 8 - Enable resus\nBit 8 - Enable resus\nBit 12 - Force a resus, for test purposes only\nBit 12 - Force a resus, for test purposes only\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBits 0:7 - This is expressed as a number of clk_ref cycles …\nBits 0:7 - This is expressed as a number of clk_ref cycles …\nYou can <code>read</code> this register and get <code>clk_sys_resus_status::R</code>…\nRegister <code>CLK_SYS_RESUS_STATUS</code> reader\nField <code>RESUSSED</code> reader - Clock has been resuscitated, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBit 0 - Clock has been resuscitated, correct the error …\nIndicates which SRC is currently selected by the …\nRegister <code>CLK_SYS_SELECTED</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSelects the auxiliary clock source, will glitch when …\nField <code>AUXSRC</code> reader - Selects the auxiliary clock source, …\nField <code>AUXSRC</code> writer - Selects the auxiliary clock source, …\n4: <code>100</code>\n5: <code>101</code>\n1: <code>1</code>\n0: <code>0</code>\nClock control, can be changed on-the-fly (except for …\nField <code>ENABLE</code> reader - Starts and stops the clock generator …\nField <code>ENABLE</code> writer - Starts and stops the clock generator …\nField <code>KILL</code> reader - Asynchronously kills the clock …\nField <code>KILL</code> writer - Asynchronously kills the clock …\nField <code>NUDGE</code> reader - An edge on this signal shifts the …\nField <code>NUDGE</code> writer - An edge on this signal shifts the …\nField <code>PHASE</code> reader - This delays the enable signal by up …\nField <code>PHASE</code> writer - This delays the enable signal by up …\nRegister <code>CLK_USB_CTRL</code> reader\n2: <code>10</code>\nRegister <code>CLK_USB_CTRL</code> writer\n3: <code>11</code>\nBits 5:7 - Selects the auxiliary clock source, will glitch …\nBits 5:7 - Selects the auxiliary clock source, will glitch …\nWrites raw bits to the register.\n<code>100</code>\n<code>101</code>\n<code>1</code>\n<code>0</code>\nBit 11 - Starts and stops the clock generator cleanly\nBit 11 - Starts and stops the clock generator cleanly\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>100</code>\n<code>101</code>\n<code>1</code>\n<code>0</code>\n<code>10</code>\n<code>11</code>\nBit 10 - Asynchronously kills the clock generator\nBit 10 - Asynchronously kills the clock generator\nBit 20 - An edge on this signal shifts the phase of the …\nBit 20 - An edge on this signal shifts the phase of the …\nBits 16:17 - This delays the enable signal by up to 3 …\nBits 16:17 - This delays the enable signal by up to 3 …\n<code>10</code>\nGet enumerated values variant\n<code>11</code>\nClock divisor, can be changed on-the-fly\nField <code>INT</code> reader - Integer component of the divisor, 0 -&gt; …\nField <code>INT</code> writer - Integer component of the divisor, 0 -&gt; …\nRegister <code>CLK_USB_DIV</code> reader\nRegister <code>CLK_USB_DIV</code> writer\nWrites raw bits to the register.\nReturns the argument unchanged.\nBits 8:9 - Integer component of the divisor, 0 -&gt; divide …\nBits 8:9 - Integer component of the divisor, 0 -&gt; divide …\nCalls <code>U::from(self)</code>.\nIndicates which SRC is currently selected by the …\nRegister <code>CLK_USB_SELECTED</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>clk_adc_adc</code> reader -\nField <code>clk_peri_spi0</code> reader -\nField <code>clk_peri_spi1</code> reader -\nField <code>clk_rtc_rtc</code> reader -\nField <code>clk_sys_adc</code> reader -\nField <code>clk_sys_busctrl</code> reader -\nField <code>clk_sys_busfabric</code> reader -\nField <code>clk_sys_clocks</code> reader -\nField <code>clk_sys_dma</code> reader -\nField <code>clk_sys_i2c0</code> reader -\nField <code>clk_sys_i2c1</code> reader -\nField <code>clk_sys_io</code> reader -\nField <code>clk_sys_jtag</code> reader -\nField <code>clk_sys_pads</code> reader -\nField <code>clk_sys_pio0</code> reader -\nField <code>clk_sys_pio1</code> reader -\nField <code>clk_sys_pll_sys</code> reader -\nField <code>clk_sys_pll_usb</code> reader -\nField <code>clk_sys_psm</code> reader -\nField <code>clk_sys_pwm</code> reader -\nField <code>clk_sys_resets</code> reader -\nField <code>clk_sys_rom</code> reader -\nField <code>clk_sys_rosc</code> reader -\nField <code>clk_sys_rtc</code> reader -\nField <code>clk_sys_sio</code> reader -\nField <code>clk_sys_spi0</code> reader -\nField <code>clk_sys_spi1</code> reader -\nField <code>clk_sys_sram0</code> reader -\nField <code>clk_sys_sram1</code> reader -\nField <code>clk_sys_sram2</code> reader -\nField <code>clk_sys_sram3</code> reader -\nField <code>clk_sys_vreg_and_chip_reset</code> reader -\nindicates the state of the clock enable\nRegister <code>ENABLED0</code> reader\nBit 1\nBit 24\nBit 26\nBit 21\nBit 2\nBit 3\nBit 4\nBit 0\nBit 5\nBit 6\nBit 7\nBit 8\nBit 9\nBit 11\nBit 12\nBit 13\nBit 14\nBit 15\nBit 16\nBit 17\nBit 18\nBit 19\nBit 20\nBit 22\nBit 23\nBit 25\nBit 27\nBit 28\nBit 29\nBit 30\nBit 31\nBit 10\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>clk_peri_uart0</code> reader -\nField <code>clk_peri_uart1</code> reader -\nField <code>clk_sys_sram4</code> reader -\nField <code>clk_sys_sram5</code> reader -\nField <code>clk_sys_syscfg</code> reader -\nField <code>clk_sys_sysinfo</code> reader -\nField <code>clk_sys_tbman</code> reader -\nField <code>clk_sys_timer</code> reader -\nField <code>clk_sys_uart0</code> reader -\nField <code>clk_sys_uart1</code> reader -\nField <code>clk_sys_usbctrl</code> reader -\nField <code>clk_sys_watchdog</code> reader -\nField <code>clk_sys_xip</code> reader -\nField <code>clk_sys_xosc</code> reader -\nField <code>clk_usb_usbctrl</code> reader -\nindicates the state of the clock enable\nRegister <code>ENABLED1</code> reader\nBit 6\nBit 8\nBit 0\nBit 1\nBit 2\nBit 3\nBit 4\nBit 5\nBit 7\nBit 9\nBit 10\nBit 12\nBit 13\nBit 14\nBit 11\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>FC0_DELAY</code> reader -\nDelays the start of frequency counting to allow the mux to …\nField <code>FC0_DELAY</code> writer -\nRegister <code>FC0_DELAY</code> reader\nRegister <code>FC0_DELAY</code> writer\nWrites raw bits to the register.\nBits 0:2\nBits 0:2\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>FC0_INTERVAL</code> reader -\nThe test interval is 0.98us * 2<strong>interval, but let’s call </strong>…\nField <code>FC0_INTERVAL</code> writer -\nRegister <code>FC0_INTERVAL</code> reader\nRegister <code>FC0_INTERVAL</code> writer\nWrites raw bits to the register.\nBits 0:3\nBits 0:3\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>FC0_MAX_KHZ</code> reader -\nMaximum pass frequency in kHz. This is optional. Set to …\nField <code>FC0_MAX_KHZ</code> writer -\nRegister <code>FC0_MAX_KHZ</code> reader\nRegister <code>FC0_MAX_KHZ</code> writer\nWrites raw bits to the register.\nBits 0:24\nBits 0:24\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>FC0_MIN_KHZ</code> reader -\nMinimum pass frequency in kHz. This is optional. Set to 0 …\nField <code>FC0_MIN_KHZ</code> writer -\nRegister <code>FC0_MIN_KHZ</code> reader\nRegister <code>FC0_MIN_KHZ</code> writer\nWrites raw bits to the register.\nBits 0:24\nBits 0:24\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>FC0_REF_KHZ</code> reader -\nReference clock frequency in kHz\nField <code>FC0_REF_KHZ</code> writer -\nRegister <code>FC0_REF_KHZ</code> reader\nRegister <code>FC0_REF_KHZ</code> writer\nWrites raw bits to the register.\nBits 0:19\nBits 0:19\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nResult of frequency measurement, only valid when …\nField <code>FRAC</code> reader -\nField <code>KHZ</code> reader -\nRegister <code>FC0_RESULT</code> reader\nBits 0:4\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBits 5:29\n6: <code>110</code>\n7: <code>111</code>\n12: <code>1100</code>\n10: <code>1010</code>\n8: <code>1000</code>\n13: <code>1101</code>\n9: <code>1001</code>\n11: <code>1011</code>\nValue on reset: 0\nField <code>FC0_SRC</code> reader -\nClock sent to frequency counter, set to 0 when not required\nField <code>FC0_SRC</code> writer -\n0: <code>0</code>\n1: <code>1</code>\n2: <code>10</code>\nRegister <code>FC0_SRC</code> reader\n3: <code>11</code>\n4: <code>100</code>\nRegister <code>FC0_SRC</code> writer\n5: <code>101</code>\nWrites raw bits to the register.\n<code>1100</code>\n<code>1010</code>\n<code>1000</code>\n<code>1101</code>\n<code>1001</code>\n<code>1011</code>\n<code>110</code>\n<code>111</code>\nBits 0:7\nBits 0:7\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>1100</code>\n<code>1010</code>\n<code>1000</code>\n<code>1101</code>\n<code>1001</code>\n<code>1011</code>\n<code>110</code>\n<code>111</code>\n<code>0</code>\n<code>1</code>\n<code>10</code>\n<code>11</code>\n<code>100</code>\n<code>101</code>\n<code>0</code>\n<code>1</code>\n<code>10</code>\n<code>11</code>\n<code>100</code>\nGet enumerated values variant\n<code>101</code>\nField <code>DIED</code> reader - Test clock stopped during test\nField <code>DONE</code> reader - Test complete\nField <code>FAIL</code> reader - Test failed\nField <code>FAST</code> reader - Test clock faster than expected, only …\nFrequency counter status\nField <code>PASS</code> reader - Test passed\nRegister <code>FC0_STATUS</code> reader\nField <code>RUNNING</code> reader - Test running\nField <code>SLOW</code> reader - Test clock slower than expected, only …\nField <code>WAITING</code> reader - Waiting for test clock to start\nBit 28 - Test clock stopped during test\nBit 4 - Test complete\nBit 16 - Test failed\nBit 24 - Test clock faster than expected, only valid when …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBit 0 - Test passed\nBit 8 - Test running\nBit 20 - Test clock slower than expected, only valid when …\nBit 12 - Waiting for test clock to start\nField <code>CLK_SYS_RESUS</code> reader -\nField <code>CLK_SYS_RESUS</code> writer -\nInterrupt Enable\nRegister <code>INTE</code> reader\nRegister <code>INTE</code> writer\nWrites raw bits to the register.\nBit 0\nBit 0\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CLK_SYS_RESUS</code> reader -\nField <code>CLK_SYS_RESUS</code> writer -\nInterrupt Force\nRegister <code>INTF</code> reader\nRegister <code>INTF</code> writer\nWrites raw bits to the register.\nBit 0\nBit 0\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CLK_SYS_RESUS</code> reader -\nRaw Interrupts\nRegister <code>INTR</code> reader\nBit 0\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CLK_SYS_RESUS</code> reader -\nInterrupt status after masking &amp; forcing\nRegister <code>INTS</code> reader\nBit 0\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>clk_adc_adc</code> reader -\nField <code>clk_adc_adc</code> writer -\nField <code>clk_peri_spi0</code> reader -\nField <code>clk_peri_spi0</code> writer -\nField <code>clk_peri_spi1</code> reader -\nField <code>clk_peri_spi1</code> writer -\nField <code>clk_rtc_rtc</code> reader -\nField <code>clk_rtc_rtc</code> writer -\nField <code>clk_sys_adc</code> reader -\nField <code>clk_sys_adc</code> writer -\nField <code>clk_sys_busctrl</code> reader -\nField <code>clk_sys_busctrl</code> writer -\nField <code>clk_sys_busfabric</code> reader -\nField <code>clk_sys_busfabric</code> writer -\nField <code>clk_sys_clocks</code> reader -\nField <code>clk_sys_clocks</code> writer -\nField <code>clk_sys_dma</code> reader -\nField <code>clk_sys_dma</code> writer -\nField <code>clk_sys_i2c0</code> reader -\nField <code>clk_sys_i2c0</code> writer -\nField <code>clk_sys_i2c1</code> reader -\nField <code>clk_sys_i2c1</code> writer -\nField <code>clk_sys_io</code> reader -\nField <code>clk_sys_io</code> writer -\nField <code>clk_sys_jtag</code> reader -\nField <code>clk_sys_jtag</code> writer -\nField <code>clk_sys_pads</code> reader -\nField <code>clk_sys_pads</code> writer -\nField <code>clk_sys_pio0</code> reader -\nField <code>clk_sys_pio0</code> writer -\nField <code>clk_sys_pio1</code> reader -\nField <code>clk_sys_pio1</code> writer -\nField <code>clk_sys_pll_sys</code> reader -\nField <code>clk_sys_pll_sys</code> writer -\nField <code>clk_sys_pll_usb</code> reader -\nField <code>clk_sys_pll_usb</code> writer -\nField <code>clk_sys_psm</code> reader -\nField <code>clk_sys_psm</code> writer -\nField <code>clk_sys_pwm</code> reader -\nField <code>clk_sys_pwm</code> writer -\nField <code>clk_sys_resets</code> reader -\nField <code>clk_sys_resets</code> writer -\nField <code>clk_sys_rom</code> reader -\nField <code>clk_sys_rom</code> writer -\nField <code>clk_sys_rosc</code> reader -\nField <code>clk_sys_rosc</code> writer -\nField <code>clk_sys_rtc</code> reader -\nField <code>clk_sys_rtc</code> writer -\nField <code>clk_sys_sio</code> reader -\nField <code>clk_sys_sio</code> writer -\nField <code>clk_sys_spi0</code> reader -\nField <code>clk_sys_spi0</code> writer -\nField <code>clk_sys_spi1</code> reader -\nField <code>clk_sys_spi1</code> writer -\nField <code>clk_sys_sram0</code> reader -\nField <code>clk_sys_sram0</code> writer -\nField <code>clk_sys_sram1</code> reader -\nField <code>clk_sys_sram1</code> writer -\nField <code>clk_sys_sram2</code> reader -\nField <code>clk_sys_sram2</code> writer -\nField <code>clk_sys_sram3</code> reader -\nField <code>clk_sys_sram3</code> writer -\nField <code>clk_sys_vreg_and_chip_reset</code> reader -\nField <code>clk_sys_vreg_and_chip_reset</code> writer -\nRegister <code>SLEEP_EN0</code> reader\nenable clock in sleep mode\nRegister <code>SLEEP_EN0</code> writer\nWrites raw bits to the register.\nBit 1\nBit 1\nBit 24\nBit 24\nBit 26\nBit 26\nBit 21\nBit 21\nBit 2\nBit 2\nBit 3\nBit 3\nBit 4\nBit 4\nBit 0\nBit 0\nBit 5\nBit 5\nBit 6\nBit 6\nBit 7\nBit 7\nBit 8\nBit 8\nBit 9\nBit 9\nBit 11\nBit 11\nBit 12\nBit 12\nBit 13\nBit 13\nBit 14\nBit 14\nBit 15\nBit 15\nBit 16\nBit 16\nBit 17\nBit 17\nBit 18\nBit 18\nBit 19\nBit 19\nBit 20\nBit 20\nBit 22\nBit 22\nBit 23\nBit 23\nBit 25\nBit 25\nBit 27\nBit 27\nBit 28\nBit 28\nBit 29\nBit 29\nBit 30\nBit 30\nBit 31\nBit 31\nBit 10\nBit 10\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>clk_peri_uart0</code> reader -\nField <code>clk_peri_uart0</code> writer -\nField <code>clk_peri_uart1</code> reader -\nField <code>clk_peri_uart1</code> writer -\nField <code>clk_sys_sram4</code> reader -\nField <code>clk_sys_sram4</code> writer -\nField <code>clk_sys_sram5</code> reader -\nField <code>clk_sys_sram5</code> writer -\nField <code>clk_sys_syscfg</code> reader -\nField <code>clk_sys_syscfg</code> writer -\nField <code>clk_sys_sysinfo</code> reader -\nField <code>clk_sys_sysinfo</code> writer -\nField <code>clk_sys_tbman</code> reader -\nField <code>clk_sys_tbman</code> writer -\nField <code>clk_sys_timer</code> reader -\nField <code>clk_sys_timer</code> writer -\nField <code>clk_sys_uart0</code> reader -\nField <code>clk_sys_uart0</code> writer -\nField <code>clk_sys_uart1</code> reader -\nField <code>clk_sys_uart1</code> writer -\nField <code>clk_sys_usbctrl</code> reader -\nField <code>clk_sys_usbctrl</code> writer -\nField <code>clk_sys_watchdog</code> reader -\nField <code>clk_sys_watchdog</code> writer -\nField <code>clk_sys_xip</code> reader -\nField <code>clk_sys_xip</code> writer -\nField <code>clk_sys_xosc</code> reader -\nField <code>clk_sys_xosc</code> writer -\nField <code>clk_usb_usbctrl</code> reader -\nField <code>clk_usb_usbctrl</code> writer -\nRegister <code>SLEEP_EN1</code> reader\nenable clock in sleep mode\nRegister <code>SLEEP_EN1</code> writer\nWrites raw bits to the register.\nBit 6\nBit 6\nBit 8\nBit 8\nBit 0\nBit 0\nBit 1\nBit 1\nBit 2\nBit 2\nBit 3\nBit 3\nBit 4\nBit 4\nBit 5\nBit 5\nBit 7\nBit 7\nBit 9\nBit 9\nBit 10\nBit 10\nBit 12\nBit 12\nBit 13\nBit 13\nBit 14\nBit 14\nBit 11\nBit 11\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>clk_adc_adc</code> reader -\nField <code>clk_adc_adc</code> writer -\nField <code>clk_peri_spi0</code> reader -\nField <code>clk_peri_spi0</code> writer -\nField <code>clk_peri_spi1</code> reader -\nField <code>clk_peri_spi1</code> writer -\nField <code>clk_rtc_rtc</code> reader -\nField <code>clk_rtc_rtc</code> writer -\nField <code>clk_sys_adc</code> reader -\nField <code>clk_sys_adc</code> writer -\nField <code>clk_sys_busctrl</code> reader -\nField <code>clk_sys_busctrl</code> writer -\nField <code>clk_sys_busfabric</code> reader -\nField <code>clk_sys_busfabric</code> writer -\nField <code>clk_sys_clocks</code> reader -\nField <code>clk_sys_clocks</code> writer -\nField <code>clk_sys_dma</code> reader -\nField <code>clk_sys_dma</code> writer -\nField <code>clk_sys_i2c0</code> reader -\nField <code>clk_sys_i2c0</code> writer -\nField <code>clk_sys_i2c1</code> reader -\nField <code>clk_sys_i2c1</code> writer -\nField <code>clk_sys_io</code> reader -\nField <code>clk_sys_io</code> writer -\nField <code>clk_sys_jtag</code> reader -\nField <code>clk_sys_jtag</code> writer -\nField <code>clk_sys_pads</code> reader -\nField <code>clk_sys_pads</code> writer -\nField <code>clk_sys_pio0</code> reader -\nField <code>clk_sys_pio0</code> writer -\nField <code>clk_sys_pio1</code> reader -\nField <code>clk_sys_pio1</code> writer -\nField <code>clk_sys_pll_sys</code> reader -\nField <code>clk_sys_pll_sys</code> writer -\nField <code>clk_sys_pll_usb</code> reader -\nField <code>clk_sys_pll_usb</code> writer -\nField <code>clk_sys_psm</code> reader -\nField <code>clk_sys_psm</code> writer -\nField <code>clk_sys_pwm</code> reader -\nField <code>clk_sys_pwm</code> writer -\nField <code>clk_sys_resets</code> reader -\nField <code>clk_sys_resets</code> writer -\nField <code>clk_sys_rom</code> reader -\nField <code>clk_sys_rom</code> writer -\nField <code>clk_sys_rosc</code> reader -\nField <code>clk_sys_rosc</code> writer -\nField <code>clk_sys_rtc</code> reader -\nField <code>clk_sys_rtc</code> writer -\nField <code>clk_sys_sio</code> reader -\nField <code>clk_sys_sio</code> writer -\nField <code>clk_sys_spi0</code> reader -\nField <code>clk_sys_spi0</code> writer -\nField <code>clk_sys_spi1</code> reader -\nField <code>clk_sys_spi1</code> writer -\nField <code>clk_sys_sram0</code> reader -\nField <code>clk_sys_sram0</code> writer -\nField <code>clk_sys_sram1</code> reader -\nField <code>clk_sys_sram1</code> writer -\nField <code>clk_sys_sram2</code> reader -\nField <code>clk_sys_sram2</code> writer -\nField <code>clk_sys_sram3</code> reader -\nField <code>clk_sys_sram3</code> writer -\nField <code>clk_sys_vreg_and_chip_reset</code> reader -\nField <code>clk_sys_vreg_and_chip_reset</code> writer -\nRegister <code>WAKE_EN0</code> reader\nRegister <code>WAKE_EN0</code> writer\nenable clock in wake mode\nWrites raw bits to the register.\nBit 1\nBit 1\nBit 24\nBit 24\nBit 26\nBit 26\nBit 21\nBit 21\nBit 2\nBit 2\nBit 3\nBit 3\nBit 4\nBit 4\nBit 0\nBit 0\nBit 5\nBit 5\nBit 6\nBit 6\nBit 7\nBit 7\nBit 8\nBit 8\nBit 9\nBit 9\nBit 11\nBit 11\nBit 12\nBit 12\nBit 13\nBit 13\nBit 14\nBit 14\nBit 15\nBit 15\nBit 16\nBit 16\nBit 17\nBit 17\nBit 18\nBit 18\nBit 19\nBit 19\nBit 20\nBit 20\nBit 22\nBit 22\nBit 23\nBit 23\nBit 25\nBit 25\nBit 27\nBit 27\nBit 28\nBit 28\nBit 29\nBit 29\nBit 30\nBit 30\nBit 31\nBit 31\nBit 10\nBit 10\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>clk_peri_uart0</code> reader -\nField <code>clk_peri_uart0</code> writer -\nField <code>clk_peri_uart1</code> reader -\nField <code>clk_peri_uart1</code> writer -\nField <code>clk_sys_sram4</code> reader -\nField <code>clk_sys_sram4</code> writer -\nField <code>clk_sys_sram5</code> reader -\nField <code>clk_sys_sram5</code> writer -\nField <code>clk_sys_syscfg</code> reader -\nField <code>clk_sys_syscfg</code> writer -\nField <code>clk_sys_sysinfo</code> reader -\nField <code>clk_sys_sysinfo</code> writer -\nField <code>clk_sys_tbman</code> reader -\nField <code>clk_sys_tbman</code> writer -\nField <code>clk_sys_timer</code> reader -\nField <code>clk_sys_timer</code> writer -\nField <code>clk_sys_uart0</code> reader -\nField <code>clk_sys_uart0</code> writer -\nField <code>clk_sys_uart1</code> reader -\nField <code>clk_sys_uart1</code> writer -\nField <code>clk_sys_usbctrl</code> reader -\nField <code>clk_sys_usbctrl</code> writer -\nField <code>clk_sys_watchdog</code> reader -\nField <code>clk_sys_watchdog</code> writer -\nField <code>clk_sys_xip</code> reader -\nField <code>clk_sys_xip</code> writer -\nField <code>clk_sys_xosc</code> reader -\nField <code>clk_sys_xosc</code> writer -\nField <code>clk_usb_usbctrl</code> reader -\nField <code>clk_usb_usbctrl</code> writer -\nRegister <code>WAKE_EN1</code> reader\nRegister <code>WAKE_EN1</code> writer\nenable clock in wake mode\nWrites raw bits to the register.\nBit 6\nBit 6\nBit 8\nBit 8\nBit 0\nBit 0\nBit 1\nBit 1\nBit 2\nBit 2\nBit 3\nBit 3\nBit 4\nBit 4\nBit 5\nBit 5\nBit 7\nBit 7\nBit 9\nBit 9\nBit 10\nBit 10\nBit 12\nBit 12\nBit 13\nBit 13\nBit 14\nBit 14\nBit 11\nBit 11\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCluster CH%s, containing CH?_READ_ADDR,CH??_READ_ADDR, CH?_…\nCH0_DBG_CTDREQ (rw) register accessor: Read: get channel …\nCH0_DBG_TCR (r) register accessor: Read to get channel …\nCH10_DBG_CTDREQ (rw) register accessor: Read: get channel …\nCH10_DBG_TCR (r) register accessor: Read to get channel …\nCH11_DBG_CTDREQ (rw) register accessor: Read: get channel …\nCH11_DBG_TCR (r) register accessor: Read to get channel …\nCH1_DBG_CTDREQ (rw) register accessor: Read: get channel …\nCH1_DBG_TCR (r) register accessor: Read to get channel …\nCH2_DBG_CTDREQ (rw) register accessor: Read: get channel …\nCH2_DBG_TCR (r) register accessor: Read to get channel …\nCH3_DBG_CTDREQ (rw) register accessor: Read: get channel …\nCH3_DBG_TCR (r) register accessor: Read to get channel …\nCH4_DBG_CTDREQ (rw) register accessor: Read: get channel …\nCH4_DBG_TCR (r) register accessor: Read to get channel …\nCH5_DBG_CTDREQ (rw) register accessor: Read: get channel …\nCH5_DBG_TCR (r) register accessor: Read to get channel …\nCH6_DBG_CTDREQ (rw) register accessor: Read: get channel …\nCH6_DBG_TCR (r) register accessor: Read to get channel …\nCH7_DBG_CTDREQ (rw) register accessor: Read: get channel …\nCH7_DBG_TCR (r) register accessor: Read to get channel …\nCH8_DBG_CTDREQ (rw) register accessor: Read: get channel …\nCH8_DBG_TCR (r) register accessor: Read to get channel …\nCH9_DBG_CTDREQ (rw) register accessor: Read: get channel …\nCH9_DBG_TCR (r) register accessor: Read to get channel …\nCHAN_ABORT (rw) register accessor: Abort an in-progress …\nFIFO_LEVELS (r) register accessor: Debug RAF, WAF, TDF …\nINTE0 (rw) register accessor: Interrupt Enables for IRQ 0\nINTE1 (rw) register accessor: Interrupt Enables for IRQ 1\nINTF0 (rw) register accessor: Force Interrupts\nINTF1 (rw) register accessor: Force Interrupts for IRQ 1\nINTR (rw) register accessor: Interrupt Status (raw)\nINTS0 (rw) register accessor: Interrupt Status for IRQ 0\nINTS1 (rw) register accessor: Interrupt Status (masked) …\nMULTI_CHAN_TRIGGER (rw) register accessor: Trigger one or …\nN_CHANNELS (r) register accessor: The number of channels …\nRegister block\nSNIFF_CTRL (rw) register accessor: Sniffer Control\nSNIFF_DATA (rw) register accessor: Data accumulator for …\nTIMER0 (rw) register accessor: Pacing (X/Y) Fractional …\nTIMER1 (rw) register accessor: Pacing (X/Y) Fractional …\nTIMER2 (rw) register accessor: Pacing (X/Y) Fractional …\nTIMER3 (rw) register accessor: Pacing (X/Y) Fractional …\nCluster Cluster CH%s, containing CH?_READ_ADDR,CH??_…\n0x00..0x300 - Cluster CH%s, containing CH?_READ_ADDR,CH??_…\nRead: get channel DREQ counter (i.e. how many accesses the …\n0x800 - Read: get channel DREQ counter (i.e. how many …\nRead to get channel TRANS_COUNT reload value, i.e. the …\n0x804 - Read to get channel TRANS_COUNT reload value, i.e. …\nRead: get channel DREQ counter (i.e. how many accesses the …\n0xa80 - Read: get channel DREQ counter (i.e. how many …\nRead to get channel TRANS_COUNT reload value, i.e. the …\n0xa84 - Read to get channel TRANS_COUNT reload value, i.e. …\nRead: get channel DREQ counter (i.e. how many accesses the …\n0xac0 - Read: get channel DREQ counter (i.e. how many …\nRead to get channel TRANS_COUNT reload value, i.e. the …\n0xac4 - Read to get channel TRANS_COUNT reload value, i.e. …\nRead: get channel DREQ counter (i.e. how many accesses the …\n0x840 - Read: get channel DREQ counter (i.e. how many …\nRead to get channel TRANS_COUNT reload value, i.e. the …\n0x844 - Read to get channel TRANS_COUNT reload value, i.e. …\nRead: get channel DREQ counter (i.e. how many accesses the …\n0x880 - Read: get channel DREQ counter (i.e. how many …\nRead to get channel TRANS_COUNT reload value, i.e. the …\n0x884 - Read to get channel TRANS_COUNT reload value, i.e. …\nRead: get channel DREQ counter (i.e. how many accesses the …\n0x8c0 - Read: get channel DREQ counter (i.e. how many …\nRead to get channel TRANS_COUNT reload value, i.e. the …\n0x8c4 - Read to get channel TRANS_COUNT reload value, i.e. …\nRead: get channel DREQ counter (i.e. how many accesses the …\n0x900 - Read: get channel DREQ counter (i.e. how many …\nRead to get channel TRANS_COUNT reload value, i.e. the …\n0x904 - Read to get channel TRANS_COUNT reload value, i.e. …\nRead: get channel DREQ counter (i.e. how many accesses the …\n0x940 - Read: get channel DREQ counter (i.e. how many …\nRead to get channel TRANS_COUNT reload value, i.e. the …\n0x944 - Read to get channel TRANS_COUNT reload value, i.e. …\nRead: get channel DREQ counter (i.e. how many accesses the …\n0x980 - Read: get channel DREQ counter (i.e. how many …\nRead to get channel TRANS_COUNT reload value, i.e. the …\n0x984 - Read to get channel TRANS_COUNT reload value, i.e. …\nRead: get channel DREQ counter (i.e. how many accesses the …\n0x9c0 - Read: get channel DREQ counter (i.e. how many …\nRead to get channel TRANS_COUNT reload value, i.e. the …\n0x9c4 - Read to get channel TRANS_COUNT reload value, i.e. …\nRead: get channel DREQ counter (i.e. how many accesses the …\n0xa00 - Read: get channel DREQ counter (i.e. how many …\nRead to get channel TRANS_COUNT reload value, i.e. the …\n0xa04 - Read to get channel TRANS_COUNT reload value, i.e. …\nRead: get channel DREQ counter (i.e. how many accesses the …\n0xa40 - Read: get channel DREQ counter (i.e. how many …\nRead to get channel TRANS_COUNT reload value, i.e. the …\n0xa44 - Read to get channel TRANS_COUNT reload value, i.e. …\nIterator for array of: 0x00..0x300 - Cluster CH%s, …\nAbort an in-progress transfer sequence on one or more …\n0x444 - Abort an in-progress transfer sequence on one or …\nDebug RAF, WAF, TDF levels\n0x440 - Debug RAF, WAF, TDF levels\nReturns the argument unchanged.\nInterrupt Enables for IRQ 0\n0x404 - Interrupt Enables for IRQ 0\nInterrupt Enables for IRQ 1\n0x414 - Interrupt Enables for IRQ 1\nForce Interrupts\n0x408 - Force Interrupts\nForce Interrupts for IRQ 1\n0x418 - Force Interrupts for IRQ 1\nCalls <code>U::from(self)</code>.\nInterrupt Status (raw)\n0x400 - Interrupt Status (raw)\nInterrupt Status for IRQ 0\n0x40c - Interrupt Status for IRQ 0\nInterrupt Status (masked) for IRQ 1\n0x41c - Interrupt Status (masked) for IRQ 1\nTrigger one or more channels simultaneously\n0x430 - Trigger one or more channels simultaneously\nThe number of channels this DMA instance is equipped with. …\n0x448 - The number of channels this DMA instance is …\nSniffer Control\n0x434 - Sniffer Control\nData accumulator for sniff hardware Write an initial seed …\n0x438 - Data accumulator for sniff hardware Write an …\nPacing (X/Y) Fractional Timer The pacing timer produces …\n0x420 - Pacing (X/Y) Fractional Timer The pacing timer …\nPacing (X/Y) Fractional Timer The pacing timer produces …\n0x424 - Pacing (X/Y) Fractional Timer The pacing timer …\nPacing (X/Y) Fractional Timer The pacing timer produces …\n0x428 - Pacing (X/Y) Fractional Timer The pacing timer …\nPacing (X/Y) Fractional Timer The pacing timer produces …\n0x42c - Pacing (X/Y) Fractional Timer The pacing timer …\nRegister block\nCH_AL1_CTRL (rw) register accessor: DMA Channel 0 Control …\nCH_AL1_READ_ADDR (rw) register accessor: Alias for channel …\nCH_AL1_TRANS_COUNT_TRIG (rw) register accessor: Alias for …\nCH_AL1_WRITE_ADDR (rw) register accessor: Alias for …\nCH_AL2_CTRL (rw) register accessor: DMA Channel 0 Control …\nCH_AL2_READ_ADDR (rw) register accessor: Alias for channel …\nCH_AL2_TRANS_COUNT (rw) register accessor: Alias for …\nCH_AL2_WRITE_ADDR_TRIG (rw) register accessor: Alias for …\nCH_AL3_CTRL (rw) register accessor: DMA Channel 0 Control …\nCH_AL3_READ_ADDR_TRIG (rw) register accessor: Alias for …\nCH_AL3_TRANS_COUNT (rw) register accessor: Alias for …\nCH_AL3_WRITE_ADDR (rw) register accessor: Alias for …\nCH_CTRL_TRIG (rw) register accessor: DMA Channel 0 Control …\nCH_READ_ADDR (rw) register accessor: DMA Channel 0 Read …\nCH_TRANS_COUNT (rw) register accessor: DMA Channel 0 …\nCH_WRITE_ADDR (rw) register accessor: DMA Channel 0 Write …\nDMA Channel 0 Control and Status\n0x10 - DMA Channel 0 Control and Status\nAlias for channel 0 READ_ADDR register\n0x14 - Alias for channel 0 READ_ADDR register\nAlias for channel 0 TRANS_COUNT register This is a trigger …\n0x1c - Alias for channel 0 TRANS_COUNT register This is a …\nAlias for channel 0 WRITE_ADDR register\n0x18 - Alias for channel 0 WRITE_ADDR register\nDMA Channel 0 Control and Status\n0x20 - DMA Channel 0 Control and Status\nAlias for channel 0 READ_ADDR register\n0x28 - Alias for channel 0 READ_ADDR register\nAlias for channel 0 TRANS_COUNT register\n0x24 - Alias for channel 0 TRANS_COUNT register\nAlias for channel 0 WRITE_ADDR register This is a trigger …\n0x2c - Alias for channel 0 WRITE_ADDR register This is a …\nDMA Channel 0 Control and Status\n0x30 - DMA Channel 0 Control and Status\nAlias for channel 0 READ_ADDR register This is a trigger …\n0x3c - Alias for channel 0 READ_ADDR register This is a …\nAlias for channel 0 TRANS_COUNT register\n0x38 - Alias for channel 0 TRANS_COUNT register\nAlias for channel 0 WRITE_ADDR register\n0x34 - Alias for channel 0 WRITE_ADDR register\nDMA Channel 0 Control and Status\n0x0c - DMA Channel 0 Control and Status\nDMA Channel 0 Read Address pointer This register updates …\n0x00 - DMA Channel 0 Read Address pointer This register …\nDMA Channel 0 Transfer Count Program the number of bus …\n0x08 - DMA Channel 0 Transfer Count Program the number of …\nDMA Channel 0 Write Address pointer This register updates …\n0x04 - DMA Channel 0 Write Address pointer This register …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CH0_DBG_CTDREQ</code> reader -\nRead: get channel DREQ counter (i.e. how many accesses the …\nField <code>CH0_DBG_CTDREQ</code> writer -\nRegister <code>CH0_DBG_CTDREQ</code> reader\nRegister <code>CH0_DBG_CTDREQ</code> writer\nWrites raw bits to the register.\nBits 0:5\nBits 0:5\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead to get channel TRANS_COUNT reload value, i.e. the …\nRegister <code>CH0_DBG_TCR</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CH10_DBG_CTDREQ</code> reader -\nRead: get channel DREQ counter (i.e. how many accesses the …\nField <code>CH10_DBG_CTDREQ</code> writer -\nRegister <code>CH10_DBG_CTDREQ</code> reader\nRegister <code>CH10_DBG_CTDREQ</code> writer\nWrites raw bits to the register.\nBits 0:5\nBits 0:5\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead to get channel TRANS_COUNT reload value, i.e. the …\nRegister <code>CH10_DBG_TCR</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CH11_DBG_CTDREQ</code> reader -\nRead: get channel DREQ counter (i.e. how many accesses the …\nField <code>CH11_DBG_CTDREQ</code> writer -\nRegister <code>CH11_DBG_CTDREQ</code> reader\nRegister <code>CH11_DBG_CTDREQ</code> writer\nWrites raw bits to the register.\nBits 0:5\nBits 0:5\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead to get channel TRANS_COUNT reload value, i.e. the …\nRegister <code>CH11_DBG_TCR</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CH1_DBG_CTDREQ</code> reader -\nRead: get channel DREQ counter (i.e. how many accesses the …\nField <code>CH1_DBG_CTDREQ</code> writer -\nRegister <code>CH1_DBG_CTDREQ</code> reader\nRegister <code>CH1_DBG_CTDREQ</code> writer\nWrites raw bits to the register.\nBits 0:5\nBits 0:5\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead to get channel TRANS_COUNT reload value, i.e. the …\nRegister <code>CH1_DBG_TCR</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CH2_DBG_CTDREQ</code> reader -\nRead: get channel DREQ counter (i.e. how many accesses the …\nField <code>CH2_DBG_CTDREQ</code> writer -\nRegister <code>CH2_DBG_CTDREQ</code> reader\nRegister <code>CH2_DBG_CTDREQ</code> writer\nWrites raw bits to the register.\nBits 0:5\nBits 0:5\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead to get channel TRANS_COUNT reload value, i.e. the …\nRegister <code>CH2_DBG_TCR</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CH3_DBG_CTDREQ</code> reader -\nRead: get channel DREQ counter (i.e. how many accesses the …\nField <code>CH3_DBG_CTDREQ</code> writer -\nRegister <code>CH3_DBG_CTDREQ</code> reader\nRegister <code>CH3_DBG_CTDREQ</code> writer\nWrites raw bits to the register.\nBits 0:5\nBits 0:5\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead to get channel TRANS_COUNT reload value, i.e. the …\nRegister <code>CH3_DBG_TCR</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CH4_DBG_CTDREQ</code> reader -\nRead: get channel DREQ counter (i.e. how many accesses the …\nField <code>CH4_DBG_CTDREQ</code> writer -\nRegister <code>CH4_DBG_CTDREQ</code> reader\nRegister <code>CH4_DBG_CTDREQ</code> writer\nWrites raw bits to the register.\nBits 0:5\nBits 0:5\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead to get channel TRANS_COUNT reload value, i.e. the …\nRegister <code>CH4_DBG_TCR</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CH5_DBG_CTDREQ</code> reader -\nRead: get channel DREQ counter (i.e. how many accesses the …\nField <code>CH5_DBG_CTDREQ</code> writer -\nRegister <code>CH5_DBG_CTDREQ</code> reader\nRegister <code>CH5_DBG_CTDREQ</code> writer\nWrites raw bits to the register.\nBits 0:5\nBits 0:5\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead to get channel TRANS_COUNT reload value, i.e. the …\nRegister <code>CH5_DBG_TCR</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CH6_DBG_CTDREQ</code> reader -\nRead: get channel DREQ counter (i.e. how many accesses the …\nField <code>CH6_DBG_CTDREQ</code> writer -\nRegister <code>CH6_DBG_CTDREQ</code> reader\nRegister <code>CH6_DBG_CTDREQ</code> writer\nWrites raw bits to the register.\nBits 0:5\nBits 0:5\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead to get channel TRANS_COUNT reload value, i.e. the …\nRegister <code>CH6_DBG_TCR</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CH7_DBG_CTDREQ</code> reader -\nRead: get channel DREQ counter (i.e. how many accesses the …\nField <code>CH7_DBG_CTDREQ</code> writer -\nRegister <code>CH7_DBG_CTDREQ</code> reader\nRegister <code>CH7_DBG_CTDREQ</code> writer\nWrites raw bits to the register.\nBits 0:5\nBits 0:5\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead to get channel TRANS_COUNT reload value, i.e. the …\nRegister <code>CH7_DBG_TCR</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CH8_DBG_CTDREQ</code> reader -\nRead: get channel DREQ counter (i.e. how many accesses the …\nField <code>CH8_DBG_CTDREQ</code> writer -\nRegister <code>CH8_DBG_CTDREQ</code> reader\nRegister <code>CH8_DBG_CTDREQ</code> writer\nWrites raw bits to the register.\nBits 0:5\nBits 0:5\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead to get channel TRANS_COUNT reload value, i.e. the …\nRegister <code>CH8_DBG_TCR</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nField <code>CH9_DBG_CTDREQ</code> reader -\nRead: get channel DREQ counter (i.e. how many accesses the …\nField <code>CH9_DBG_CTDREQ</code> writer -\nRegister <code>CH9_DBG_CTDREQ</code> reader\nRegister <code>CH9_DBG_CTDREQ</code> writer\nWrites raw bits to the register.\nBits 0:5\nBits 0:5\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead to get channel TRANS_COUNT reload value, i.e. the …\nRegister <code>CH9_DBG_TCR</code> reader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n36: Select the ADC as TREQ\nField <code>AHB_ERROR</code> reader - Logical OR of the READ_ERROR and …\nField <code>BSWAP</code> reader - Apply byte-swap transformation to DMA …\nField <code>BSWAP</code> writer - Apply byte-swap transformation to DMA …\nField <code>BUSY</code> reader - This flag goes high when the channel …\nField <code>CHAIN_TO</code> reader - When this channel completes, it …\nField <code>CHAIN_TO</code> writer - When this channel completes, it …\nDMA Channel 0 Control and Status\nSet the size of each bus transfer (byte/halfword/word). …\nField <code>DATA_SIZE</code> reader - Set the size of each bus transfer …\nField <code>DATA_SIZE</code> writer - Set the size of each bus transfer …\nField <code>EN</code> reader - DMA Channel Enable. When 1, the channel …\nField <code>EN</code> writer - DMA Channel Enable. When 1, the channel …\nField <code>HIGH_PRIORITY</code> reader - HIGH_PRIORITY gives a channel …\nField <code>HIGH_PRIORITY</code> writer - HIGH_PRIORITY gives a channel …\n33: Select I2C0’s RX FIFO as TREQ\n32: Select I2C0’s TX FIFO as TREQ\n35: Select I2C1’s RX FIFO as TREQ\n34: Select I2C1’s TX FIFO as TREQ\nField <code>INCR_READ</code> reader - If 1, the read address increments …\nField <code>INCR_READ</code> writer - If 1, the read address increments …\nField <code>INCR_WRITE</code> reader - If 1, the write address …\nField <code>INCR_WRITE</code> writer - If 1, the write address …\nField <code>IRQ_QUIET</code> reader - In QUIET mode, the channel does …\nField <code>IRQ_QUIET</code> writer - In QUIET mode, the channel does …\n63: Permanent request, for unpaced transfers.\n4: Select PIO0’s RX FIFO 0 as TREQ\n5: Select PIO0’s RX FIFO 1 as TREQ\n6: Select PIO0’s RX FIFO 2 as TREQ\n7: Select PIO0’s RX FIFO 3 as TREQ\n0: Select PIO0’s TX FIFO 0 as TREQ\n1: Select PIO0’s TX FIFO 1 as TREQ\n2: Select PIO0’s TX FIFO 2 as TREQ\n3: Select PIO0’s TX FIFO 3 as TREQ\n12: Select PIO1’s RX FIFO 0 as TREQ\n13: Select PIO1’s RX FIFO 1 as TREQ\n14: Select PIO1’s RX FIFO 2 as TREQ\n15: Select PIO1’s RX FIFO 3 as TREQ\n8: Select PIO1’s TX FIFO 0 as TREQ\n9: Select PIO1’s TX FIFO 1 as TREQ\n10: Select PIO1’s TX FIFO 2 as TREQ\n11: Select PIO1’s TX FIFO 3 as TREQ\n24: Select PWM Counter 0’s Wrap Value as TREQ\n25: Select PWM Counter 1’s Wrap Value as TREQ\n26: Select PWM Counter 2’s Wrap Value as TREQ\n27: Select PWM Counter 3’s Wrap Value as TREQ\n28: Select PWM Counter 4’s Wrap Value as TREQ\n29: Select PWM Counter 5’s Wrap Value as TREQ\n30: Select PWM Counter 6’s Wrap Value as TREQ\n31: Select PWM Counter 7’s Wrap Value as TREQ\nRegister <code>CH_AL1_CTRL</code> reader\nField <code>READ_ERROR</code> reader - If 1, the channel received a …\nField <code>READ_ERROR</code> writer - If 1, the channel received a …\n0: <code>0</code>\nField <code>RING_SEL</code> reader - Select whether RING_SIZE applies …\nField <code>RING_SEL</code> writer - Select whether RING_SIZE applies …\nSize of address wrap region. If 0, don’t wrap. For …\nField <code>RING_SIZE</code> reader - Size of address wrap region. If …\nField <code>RING_SIZE</code> writer - Size of address wrap region. If …\n0: <code>0</code>\n1: <code>1</code>\n2: <code>10</code>\nField <code>SNIFF_EN</code> reader - If 1, this channel’s data …\nField <code>SNIFF_EN</code> writer - If 1, this channel’s data …\n17: Select SPI0’s RX FIFO as TREQ\n16: Select SPI0’s TX FIFO as TREQ\n19: Select SPI1’s RX FIFO as TREQ\n18: Select SPI1’s TX FIFO as TREQ\n59: Select Timer 0 as TREQ\n60: Select Timer 1 as TREQ\n61: Select Timer 2 as TREQ (Optional)\n62: Select Timer 3 as TREQ (Optional)\nSelect a Transfer Request signal. The channel uses the …\nField <code>TREQ_SEL</code> reader - Select a Transfer Request signal. …\nField <code>TREQ_SEL</code> writer - Select a Transfer Request signal. …\n21: Select UART0’s RX FIFO as TREQ\n20: Select UART0’s TX FIFO as TREQ\n23: Select UART1’s RX FIFO as TREQ\n22: Select UART1’s TX FIFO as TREQ\nRegister <code>CH_AL1_CTRL</code> writer\nField <code>WRITE_ERROR</code> reader - If 1, the channel received a …\nField <code>WRITE_ERROR</code> writer - If 1, the channel received a …\n39: Select the XIP SSI RX FIFO as TREQ\n38: Select the XIP SSI TX FIFO as TREQ\n37: Select the XIP Streaming FIFO as TREQ\nSelect the ADC as TREQ\nBit 31 - Logical OR of the READ_ERROR and WRITE_ERROR …\nWrites raw bits to the register.\nBit 22 - Apply byte-swap transformation to DMA data. For …\nBit 22 - Apply byte-swap transformation to DMA data. For …\nBit 24 - This flag goes high when the channel starts a new …\nBits 11:14 - When this channel completes, it will trigger …\nBits 11:14 - When this channel completes, it will trigger …\nBits 2:3 - Set the size of each bus transfer …\nBits 2:3 - Set the size of each bus transfer …\nBit 0 - DMA Channel Enable. When 1, the channel will …\nBit 0 - DMA Channel Enable. When 1, the channel will …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBit 1 - HIGH_PRIORITY gives a channel preferential …\nBit 1 - HIGH_PRIORITY gives a channel preferential …\nSelect I2C0’s RX FIFO as TREQ\nSelect I2C0’s TX FIFO as TREQ\nSelect I2C1’s RX FIFO as TREQ\nSelect I2C1’s TX FIFO as TREQ\nBit 4 - If 1, the read address increments with each …\nBit 4 - If 1, the read address increments with each …\nBit 5 - If 1, the write address increments with each …\nBit 5 - If 1, the write address increments with each …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBit 21 - In QUIET mode, the channel does not generate IRQs …\nBit 21 - In QUIET mode, the channel does not generate IRQs …\nSelect the ADC as TREQ\nSelect I2C0’s RX FIFO as TREQ\nSelect I2C0’s TX FIFO as TREQ\nSelect I2C1’s RX FIFO as TREQ\nSelect I2C1’s TX FIFO as TREQ\nPermanent request, for unpaced transfers.\nSelect PIO0’s RX FIFO 0 as TREQ\nSelect PIO0’s RX FIFO 1 as TREQ\nSelect PIO0’s RX FIFO 2 as TREQ\nSelect PIO0’s RX FIFO 3 as TREQ\nSelect PIO0’s TX FIFO 0 as TREQ\nSelect PIO0’s TX FIFO 1 as TREQ\nSelect PIO0’s TX FIFO 2 as TREQ\nSelect PIO0’s TX FIFO 3 as TREQ\nSelect PIO1’s RX FIFO 0 as TREQ\nSelect PIO1’s RX FIFO 1 as TREQ\nSelect PIO1’s RX FIFO 2 as TREQ\nSelect PIO1’s RX FIFO 3 as TREQ\nSelect PIO1’s TX FIFO 0 as TREQ\nSelect PIO1’s TX FIFO 1 as TREQ\nSelect PIO1’s TX FIFO 2 as TREQ\nSelect PIO1’s TX FIFO 3 as TREQ\nSelect PWM Counter 0’s Wrap Value as TREQ\nSelect PWM Counter 1’s Wrap Value as TREQ\nSelect PWM Counter 2’s Wrap Value as TREQ\nSelect PWM Counter 3’s Wrap Value as TREQ\nSelect PWM Counter 4’s Wrap Value as TREQ\nSelect PWM Counter 5’s Wrap Value as TREQ\nSelect PWM Counter 6’s Wrap Value as TREQ\nSelect PWM Counter 7’s Wrap Value as TREQ\n<code>0</code>\n<code>0</code>\n<code>1</code>\n<code>10</code>\nSelect SPI0’s RX FIFO as TREQ\nSelect SPI0’s TX FIFO as TREQ\nSelect SPI1’s RX FIFO as TREQ\nSelect SPI1’s TX FIFO as TREQ\nSelect Timer 0 as TREQ\nSelect Timer 1 as TREQ\nSelect Timer 2 as TREQ (Optional)\nSelect Timer 3 as TREQ (Optional)\nSelect UART0’s RX FIFO as TREQ\nSelect UART0’s TX FIFO as TREQ\nSelect UART1’s RX FIFO as TREQ\nSelect UART1’s TX FIFO as TREQ\nSelect the XIP SSI RX FIFO as TREQ\nSelect the XIP SSI TX FIFO as TREQ\nSelect the XIP Streaming FIFO as TREQ\nPermanent request, for unpaced transfers.\nSelect PIO0’s RX FIFO 0 as TREQ\nSelect PIO0’s RX FIFO 1 as TREQ\nSelect PIO0’s RX FIFO 2 as TREQ\nSelect PIO0’s RX FIFO 3 as TREQ\nSelect PIO0’s TX FIFO 0 as TREQ\nSelect PIO0’s TX FIFO 1 as TREQ\nSelect PIO0’s TX FIFO 2 as TREQ\nSelect PIO0’s TX FIFO 3 as TREQ\nSelect PIO1’s RX FIFO 0 as TREQ\nSelect PIO1’s RX FIFO 1 as TREQ\nSelect PIO1’s RX FIFO 2 as TREQ\nSelect PIO1’s RX FIFO 3 as TREQ\nSelect PIO1’s TX FIFO 0 as TREQ\nSelect PIO1’s TX FIFO 1 as TREQ\nSelect PIO1’s TX FIFO 2 as TREQ\nSelect PIO1’s TX FIFO 3 as TREQ\nSelect PWM Counter 0’s Wrap Value as TREQ\nSelect PWM Counter 1’s Wrap Value as TREQ\nSelect PWM Counter 2’s Wrap Value as TREQ\nSelect PWM Counter 3’s Wrap Value as TREQ\nSelect PWM Counter 4’s Wrap Value as TREQ\nSelect PWM Counter 5’s Wrap Value as TREQ\nSelect PWM Counter 6’s Wrap Value as TREQ\nSelect PWM Counter 7’s Wrap Value as TREQ\nBit 30 - If 1, the channel received a read bus error. …\nBit 30 - If 1, the channel received a read bus error. …\n<code>0</code>\nBit 10 - Select whether RING_SIZE applies to read or write …\nBit 10 - Select whether RING_SIZE applies to read or write …\nBits 6:9 - Size of address wrap region. If 0, don’t …\nBits 6:9 - Size of address wrap region. If 0, don’t …\n<code>0</code>\n<code>1</code>\n<code>10</code>\nBit 23 - If 1, this channel’s data transfers are visible …\nBit 23 - If 1, this channel’s data transfers are visible …\nSelect SPI0’s RX FIFO as TREQ\nSelect SPI0’s TX FIFO as TREQ\nSelect SPI1’s RX FIFO as TREQ\nSelect SPI1’s TX FIFO as TREQ\nSelect Timer 0 as TREQ\nSelect Timer 1 as TREQ\nSelect Timer 2 as TREQ (Optional)\nSelect Timer 3 as TREQ (Optional)\nBits 15:20 - Select a Transfer Request signal. The channel …\nBits 15:20 - Select a Transfer Request signal. The channel …\nSelect UART0’s RX FIFO as TREQ\nSelect UART0’s TX FIFO as TREQ\nSelect UART1’s RX FIFO as TREQ\nSelect UART1’s TX FIFO as TREQ\nGet enumerated values variant\nGet enumerated values variant\nGet enumerated values variant\nBit 29 - If 1, the channel received a write bus error. …\nBit 29 - If 1, the channel received a write bus error. …\nSelect the XIP SSI RX FIFO as TREQ\nSelect the XIP SSI TX FIFO as TREQ\nSelect the XIP Streaming FIFO as TREQ\nAlias for channel 0 READ_ADDR register\nRegister <code>CH_AL1_READ_ADDR</code> reader\nRegister <code>CH_AL1_READ_ADDR</code> writer\nWrites raw bits to the register.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAlias for channel 0 TRANS_COUNT register This is a trigger …\nRegister <code>CH_AL1_TRANS_COUNT_TRIG</code> reader\nRegister <code>CH_AL1_TRANS_COUNT_TRIG</code> writer\nWrites raw bits to the register.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAlias for channel 0 WRITE_ADDR register\nRegister <code>CH_AL1_WRITE_ADDR</code> reader\nRegister <code>CH_AL1_WRITE_ADDR</code> writer\nWrites raw bits to the register.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n36: Select the ADC as TREQ\nField <code>AHB_ERROR</code> reader - Logical OR of the READ_ERROR and …\nField <code>BSWAP</code> reader - Apply byte-swap transformation to DMA …\nField <code>BSWAP</code> writer - Apply byte-swap transformation to DMA …\nField <code>BUSY</code> reader - This flag goes high when the channel …\nField <code>CHAIN_TO</code> reader - When this channel completes, it …\nField <code>CHAIN_TO</code> writer - When this channel completes, it …\nDMA Channel 0 Control and Status\nSet the size of each bus transfer (byte/halfword/word). …\nField <code>DATA_SIZE</code> reader - Set the size of each bus transfer …\nField <code>DATA_SIZE</code> writer - Set the size of each bus transfer …\nField <code>EN</code> reader - DMA Channel Enable. When 1, the channel …\nField <code>EN</code> writer - DMA Channel Enable. When 1, the channel …\nField <code>HIGH_PRIORITY</code> reader - HIGH_PRIORITY gives a channel …\nField <code>HIGH_PRIORITY</code> writer - HIGH_PRIORITY gives a channel …\n33: Select I2C0’s RX FIFO as TREQ\n32: Select I2C0’s TX FIFO as TREQ\n35: Select I2C1’s RX FIFO as TREQ\n34: Select I2C1’s TX FIFO as TREQ\nField <code>INCR_READ</code> reader - If 1, the read address increments …\nField <code>INCR_READ</code> writer - If 1, the read address increments …\nField <code>INCR_WRITE</code> reader - If 1, the write address …\nField <code>INCR_WRITE</code> writer - If 1, the write address …\nField <code>IRQ_QUIET</code> reader - In QUIET mode, the channel does …\nField <code>IRQ_QUIET</code> writer - In QUIET mode, the channel does …\n63: Permanent request, for unpaced transfers.\n4: Select PIO0’s RX FIFO 0 as TREQ\n5: Select PIO0’s RX FIFO 1 as TREQ\n6: Select PIO0’s RX FIFO 2 as TREQ\n7: Select PIO0’s RX FIFO 3 as TREQ\n0: Select PIO0’s TX FIFO 0 as TREQ\n1: Select PIO0’s TX FIFO 1 as TREQ\n2: Select PIO0’s TX FIFO 2 as TREQ\n3: Select PIO0’s TX FIFO 3 as TREQ\n12: Select PIO1’s RX FIFO 0 as TREQ\n13: Select PIO1’s RX FIFO 1 as TREQ\n14: Select PIO1’s RX FIFO 2 as TREQ\n15: Select PIO1’s RX FIFO 3 as TREQ\n8: Select PIO1’s TX FIFO 0 as TREQ\n9: Select PIO1’s TX FIFO 1 as TREQ\n10: Select PIO1’s TX FIFO 2 as TREQ\n11: Select PIO1’s TX FIFO 3 as TREQ\n24: Select PWM Counter 0’s Wrap Value as TREQ\n25: Select PWM Counter 1’s Wrap Value as TREQ\n26: Select PWM Counter 2’s Wrap Value as TREQ\n27: Select PWM Counter 3’s Wrap Value as TREQ\n28: Select PWM Counter 4’s Wrap Value as TREQ\n29: Select PWM Counter 5’s Wrap Value as TREQ\n30: Select PWM Counter 6’s Wrap Value as TREQ\n31: Select PWM Counter 7’s Wrap Value as TREQ\nRegister <code>CH_AL2_CTRL</code> reader\nField <code>READ_ERROR</code> reader - If 1, the channel received a …\nField <code>READ_ERROR</code> writer - If 1, the channel received a …\n0: <code>0</code>\nField <code>RING_SEL</code> reader - Select whether RING_SIZE applies …\nField <code>RING_SEL</code> writer - Select whether RING_SIZE applies …\nSize of address wrap region. If 0, don’t wrap. For …\nField <code>RING_SIZE</code> reader - Size of address wrap region. If …\nField <code>RING_SIZE</code> writer - Size of address wrap region. If …\n0: <code>0</code>\n1: <code>1</code>\n2: <code>10</code>\nField <code>SNIFF_EN</code> reader - If 1, this channel’s data …\nField <code>SNIFF_EN</code> writer - If 1, this channel’s data …\n17: Select SPI0’s RX FIFO as TREQ\n16: Select SPI0’s TX FIFO as TREQ\n19: Select SPI1’s RX FIFO as TREQ\n18: Select SPI1’s TX FIFO as TREQ\n59: Select Timer 0 as TREQ\n60: Select Timer 1 as TREQ\n61: Select Timer 2 as TREQ (Optional)\n62: Select Timer 3 as TREQ (Optional)\nSelect a Transfer Request signal. The channel uses the …\nField <code>TREQ_SEL</code> reader - Select a Transfer Request signal. …\nField <code>TREQ_SEL</code> writer - Select a Transfer Request signal. …\n21: Select UART0’s RX FIFO as TREQ\n20: Select UART0’s TX FIFO as TREQ\n23: Select UART1’s RX FIFO as TREQ\n22: Select UART1’s TX FIFO as TREQ\nRegister <code>CH_AL2_CTRL</code> writer\nField <code>WRITE_ERROR</code> reader - If 1, the channel received a …\nField <code>WRITE_ERROR</code> writer - If 1, the channel received a …\n39: Select the XIP SSI RX FIFO as TREQ\n38: Select the XIP SSI TX FIFO as TREQ\n37: Select the XIP Streaming FIFO as TREQ\nSelect the ADC as TREQ\nBit 31 - Logical OR of the READ_ERROR and WRITE_ERROR …\nWrites raw bits to the register.\nBit 22 - Apply byte-swap transformation to DMA data. For …\nBit 22 - Apply byte-swap transformation to DMA data. For …\nBit 24 - This flag goes high when the channel starts a new …\nBits 11:14 - When this channel completes, it will trigger …\nBits 11:14 - When this channel completes, it will trigger …\nBits 2:3 - Set the size of each bus transfer …\nBits 2:3 - Set the size of each bus transfer …\nBit 0 - DMA Channel Enable. When 1, the channel will …\nBit 0 - DMA Channel Enable. When 1, the channel will …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBit 1 - HIGH_PRIORITY gives a channel preferential …\nBit 1 - HIGH_PRIORITY gives a channel preferential …\nSelect I2C0’s RX FIFO as TREQ\nSelect I2C0’s TX FIFO as TREQ\nSelect I2C1’s RX FIFO as TREQ\nSelect I2C1’s TX FIFO as TREQ\nBit 4 - If 1, the read address increments with each …\nBit 4 - If 1, the read address increments with each …\nBit 5 - If 1, the write address increments with each …\nBit 5 - If 1, the write address increments with each …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBit 21 - In QUIET mode, the channel does not generate IRQs …\nBit 21 - In QUIET mode, the channel does not generate IRQs …\nSelect the ADC as TREQ\nSelect I2C0’s RX FIFO as TREQ\nSelect I2C0’s TX FIFO as TREQ\nSelect I2C1’s RX FIFO as TREQ\nSelect I2C1’s TX FIFO as TREQ\nPermanent request, for unpaced transfers.\nSelect PIO0’s RX FIFO 0 as TREQ\nSelect PIO0’s RX FIFO 1 as TREQ\nSelect PIO0’s RX FIFO 2 as TREQ\nSelect PIO0’s RX FIFO 3 as TREQ\nSelect PIO0’s TX FIFO 0 as TREQ\nSelect PIO0’s TX FIFO 1 as TREQ\nSelect PIO0’s TX FIFO 2 as TREQ\nSelect PIO0’s TX FIFO 3 as TREQ\nSelect PIO1’s RX FIFO 0 as TREQ\nSelect PIO1’s RX FIFO 1 as TREQ\nSelect PIO1’s RX FIFO 2 as TREQ\nSelect PIO1’s RX FIFO 3 as TREQ\nSelect PIO1’s TX FIFO 0 as TREQ\nSelect PIO1’s TX FIFO 1 as TREQ\nSelect PIO1’s TX FIFO 2 as TREQ\nSelect PIO1’s TX FIFO 3 as TREQ\nSelect PWM Counter 0’s Wrap Value as TREQ\nSelect PWM Counter 1’s Wrap Value as TREQ\nSelect PWM Counter 2’s Wrap Value as TREQ\nSelect PWM Counter 3’s Wrap Value as TREQ\nSelect PWM Counter 4’s Wrap Value as TREQ\nSelect PWM Counter 5’s Wrap Value as TREQ\nSelect PWM Counter 6’s Wrap Value as TREQ\nSelect PWM Counter 7’s Wrap Value as TREQ\n<code>0</code>\n<code>0</code>\n<code>1</code>\n<code>10</code>\nSelect SPI0’s RX FIFO as TREQ\nSelect SPI0’s TX FIFO as TREQ\nSelect SPI1’s RX FIFO as TREQ\nSelect SPI1’s TX FIFO as TREQ\nSelect Timer 0 as TREQ\nSelect Timer 1 as TREQ\nSelect Timer 2 as TREQ (Optional)\nSelect Timer 3 as TREQ (Optional)\nSelect UART0’s RX FIFO as TREQ\nSelect UART0’s TX FIFO as TREQ\nSelect UART1’s RX FIFO as TREQ\nSelect UART1’s TX FIFO as TREQ\nSelect the XIP SSI RX FIFO as TREQ\nSelect the XIP SSI TX FIFO as TREQ\nSelect the XIP Streaming FIFO as TREQ\nPermanent request, for unpaced transfers.\nSelect PIO0’s RX FIFO 0 as TREQ\nSelect PIO0’s RX FIFO 1 as TREQ\nSelect PIO0’s RX FIFO 2 as TREQ\nSelect PIO0’s RX FIFO 3 as TREQ\nSelect PIO0’s TX FIFO 0 as TREQ\nSelect PIO0’s TX FIFO 1 as TREQ\nSelect PIO0’s TX FIFO 2 as TREQ\nSelect PIO0’s TX FIFO 3 as TREQ\nSelect PIO1’s RX FIFO 0 as TREQ\nSelect PIO1’s RX FIFO 1 as TREQ\nSelect PIO1’s RX FIFO 2 as TREQ\nSelect PIO1’s RX FIFO 3 as TREQ\nSelect PIO1’s TX FIFO 0 as TREQ\nSelect PIO1’s TX FIFO 1 as TREQ\nSelect PIO1’s TX FIFO 2 as TREQ\nSelect PIO1’s TX FIFO 3 as TREQ\nSelect PWM Counter 0’s Wrap Value as TREQ\nSelect PWM Counter 1’s Wrap Value as TREQ\nSelect PWM Counter 2’s Wrap Value as TREQ\nSelect PWM Counter 3’s Wrap Value as TREQ\nSelect PWM Counter 4’s Wrap Value as TREQ\nSelect PWM Counter 5’s Wrap Value as TREQ\nSelect PWM Counter 6’s Wrap Value as TREQ\nSelect PWM Counter 7’s Wrap Value as TREQ\nBit 30 - If 1, the channel received a read bus error. …\nBit 30 - If 1, the channel received a read bus error. …\n<code>0</code>\nBit 10 - Select whether RING_SIZE applies to read or write …\nBit 10 - Select whether RING_SIZE applies to read or write …\nBits 6:9 - Size of address wrap region. If 0, don’t …\nBits 6:9 - Size of address wrap region. If 0, don’t …\n<code>0</code>\n<code>1</code>\n<code>10</code>\nBit 23 - If 1, this channel’s data transfers are visible …\nBit 23 - If 1, this channel’s data transfers are visible …\nSelect SPI0’s RX FIFO as TREQ\nSelect SPI0’s TX FIFO as TREQ\nSelect SPI1’s RX FIFO as TREQ\nSelect SPI1’s TX FIFO as TREQ\nSelect Timer 0 as TREQ\nSelect Timer 1 as TREQ\nSelect Timer 2 as TREQ (Optional)\nSelect Timer 3 as TREQ (Optional)\nBits 15:20 - Select a Transfer Request signal. The channel …\nBits 15:20 - Select a Transfer Request signal. The channel …\nSelect UART0’s RX FIFO as TREQ\nSelect UART0’s TX FIFO as TREQ\nSelect UART1’s RX FIFO as TREQ\nSelect UART1’s TX FIFO as TREQ\nGet enumerated values variant\nGet enumerated values variant\nGet enumerated values variant\nBit 29 - If 1, the channel received a write bus error. …\nBit 29 - If 1, the channel received a write bus error. …\nSelect the XIP SSI RX FIFO as TREQ\nSelect the XIP SSI TX FIFO as TREQ\nSelect the XIP Streaming FIFO as TREQ\nAlias for channel 0 READ_ADDR register\nRegister <code>CH_AL2_READ_ADDR</code> reader\nRegister <code>CH_AL2_READ_ADDR</code> writer\nWrites raw bits to the register.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAlias for channel 0 TRANS_COUNT register\nRegister <code>CH_AL2_TRANS_COUNT</code> reader\nRegister <code>CH_AL2_TRANS_COUNT</code> writer\nWrites raw bits to the register.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAlias for channel 0 WRITE_ADDR register This is a trigger …\nRegister <code>CH_AL2_WRITE_ADDR_TRIG</code> reader\nRegister <code>CH_AL2_WRITE_ADDR_TRIG</code> writer\nWrites raw bits to the register.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n36: Select the ADC as TREQ\nField <code>AHB_ERROR</code> reader - Logical OR of the READ_ERROR and …\nField <code>BSWAP</code> reader - Apply byte-swap transformation to DMA …\nField <code>BSWAP</code> writer - Apply byte-swap transformation to DMA …\nField <code>BUSY</code> reader - This flag goes high when the channel …\nField <code>CHAIN_TO</code> reader - When this channel completes, it …\nField <code>CHAIN_TO</code> writer - When this channel completes, it …\nDMA Channel 0 Control and Status\nSet the size of each bus transfer (byte/halfword/word). …\nField <code>DATA_SIZE</code> reader - Set the size of each bus transfer …\nField <code>DATA_SIZE</code> writer - Set the size of each bus transfer …\nField <code>EN</code> reader - DMA Channel Enable. When 1, the channel …\nField <code>EN</code> writer - DMA Channel Enable. When 1, the channel …\nField <code>HIGH_PRIORITY</code> reader - HIGH_PRIORITY gives a channel …\nField <code>HIGH_PRIORITY</code> writer - HIGH_PRIORITY gives a channel …\n33: Select I2C0’s RX FIFO as TREQ\n32: Select I2C0’s TX FIFO as TREQ\n35: Select I2C1’s RX FIFO as TREQ\n34: Select I2C1’s TX FIFO as TREQ\nField <code>INCR_READ</code> reader - If 1, the read address increments …\nField <code>INCR_READ</code> writer - If 1, the read address increments …\nField <code>INCR_WRITE</code> reader - If 1, the write address …\nField <code>INCR_WRITE</code> writer - If 1, the write address …\nField <code>IRQ_QUIET</code> reader - In QUIET mode, the channel does …\nField <code>IRQ_QUIET</code> writer - In QUIET mode, the channel does …\n63: Permanent request, for unpaced transfers.\n4: Select PIO0’s RX FIFO 0 as TREQ\n5: Select PIO0’s RX FIFO 1 as TREQ\n6: Select PIO0’s RX FIFO 2 as TREQ\n7: Select PIO0’s RX FIFO 3 as TREQ\n0: Select PIO0’s TX FIFO 0 as TREQ\n1: Select PIO0’s TX FIFO 1 as TREQ\n2: Select PIO0’s TX FIFO 2 as TREQ\n3: Select PIO0’s TX FIFO 3 as TREQ\n12: Select PIO1’s RX FIFO 0 as TREQ\n13: Select PIO1’s RX FIFO 1 as TREQ\n14: Select PIO1’s RX FIFO 2 as TREQ\n15: Select PIO1’s RX FIFO 3 as TREQ\n8: Select PIO1’s TX FIFO 0 as TREQ\n9: Select PIO1’s TX FIFO 1 as TREQ\n10: Select PIO1’s TX FIFO 2 as TREQ\n11: Select PIO1’s TX FIFO 3 as TREQ\n24: Select PWM Counter 0’s Wrap Value as TREQ\n25: Select PWM Counter 1’s Wrap Value as TREQ\n26: Select PWM Counter 2’s Wrap Value as TREQ\n27: Select PWM Counter 3’s Wrap Value as TREQ\n28: Select PWM Counter 4’s Wrap Value as TREQ\n29: Select PWM Counter 5’s Wrap Value as TREQ\n30: Select PWM Counter 6’s Wrap Value as TREQ\n31: Select PWM Counter 7’s Wrap Value as TREQ\nRegister <code>CH_AL3_CTRL</code> reader\nField <code>READ_ERROR</code> reader - If 1, the channel received a …\nField <code>READ_ERROR</code> writer - If 1, the channel received a …\n0: <code>0</code>\nField <code>RING_SEL</code> reader - Select whether RING_SIZE applies …\nField <code>RING_SEL</code> writer - Select whether RING_SIZE applies …\nSize of address wrap region. If 0, don’t wrap. For …\nField <code>RING_SIZE</code> reader - Size of address wrap region. If …\nField <code>RING_SIZE</code> writer - Size of address wrap region. If …\n0: <code>0</code>\n1: <code>1</code>\n2: <code>10</code>\nField <code>SNIFF_EN</code> reader - If 1, this channel’s data …\nField <code>SNIFF_EN</code> writer - If 1, this channel’s data …\n17: Select SPI0’s RX FIFO as TREQ\n16: Select SPI0’s TX FIFO as TREQ\n19: Select SPI1’s RX FIFO as TREQ\n18: Select SPI1’s TX FIFO as TREQ\n59: Select Timer 0 as TREQ\n60: Select Timer 1 as TREQ")