searchState.loadedDescShard("rtic_sync", 0, "Synchronization primitives for asynchronous contexts.\nA Mutex-like FIFO with unlimited-waiter for embedded …\nAn async aware MPSC channel that can be used on no-alloc …\nCreates a split channel with <code>&#39;static</code> lifetime.\nCreates a split signal with <code>&#39;static</code> lifetime.\nA “latest only” value store with unlimited writers and …\nAn FIFO waitqueue for use in shared bus usecases.\nThis token represents exclusive access to the value …\nGet access to the inner value in the <code>Arbiter</code>. This will …\nReturns the argument unchanged.\nReturns the argument unchanged.\nI2C bus sharing using <code>Arbiter</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new arbiter.\nSPI bus sharing using <code>Arbiter</code>\nNon-blockingly tries to access the underlying value. If …\n<code>Arbiter</code>-based shared bus implementation for I2C.\n<code>Arbiter</code>-based shared bus implementation for I2C.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an <code>ArbiterDevice</code> from an <code>BlockingArbiterDevice</code>.\nCreate a new <code>ArbiterDevice</code> for I2C.\nCreate a new <code>BlockingArbiterDevice</code> for I2C.\n<code>Arbiter</code>-based shared bus implementation.\n<code>Arbiter</code>-based shared bus implementation.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an <code>ArbiterDevice</code> from an <code>BlockingArbiterDevice</code>.\nCreate a new <code>ArbiterDevice</code>.\nCreate a new <code>BlockingArbiterDevice</code>.\nAn MPSC channel for use in no-alloc systems. <code>N</code> sets the …\nError state for when the queue is empty.\nError state when the queue is full.\nError state for when the receiver has been dropped.\nError state for when the receiver has been dropped.\nError state for when all senders has been dropped.\nPossible receive errors.\nA receiver of the channel. There can only be one receiver …\nA <code>Sender</code> can send to the channel and can be cloned.\nErrors that ’try_send` can have.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if there is no <code>Receiver</code>s.\nReturns true if there are no <code>Sender</code>s.\nIs the queue empty.\nIs the queue empty.\nIs the queue full.\nIs the queue full.\nCreate a new channel.\nReceives a value, waiting if the queue is empty. If all …\nSend a value. If there is no place left in the queue this …\nSplit the queue into a <code>Sender</code>/<code>Receiver</code> pair.\nReceives a value if there is one in the channel, …\nTry to send a value, non-blocking. If the channel is full …\nA “latest only” value store with unlimited writers and …\nFacilitates the async reading of values from the Signal.\nFacilitates the writing of values to a Signal.\nClear the stored value in the Signal (if any).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new signal.\nSplit the signal into a writer and reader.\nReturns a pending value if present, or None if no value is …\nWait for a new value to be written and read it.\nWait for a new value to be written and read it.\nWrite a value to the Signal.")